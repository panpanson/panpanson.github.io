{"pages":[],"posts":[{"title":"设计模式","text":"设计模式：单例模式、策略模式、装饰者模式、发布订阅模式、代理模式（待补充） 单例模式单例模式两个条件 确保只有一个实例 可以全局访问 12345678910111213const singleton = function (name) { this.name = name; this.instance = null;}singleton.prototype.getName = function() { return this.name}singleton.getInstance = function(name) { if (!this.instance) { // 关键点 this.instance = new singleton(name) } return this.instance} 策略模式根据不同参数可以命中不同的策略，优点有 能减少大量的 if 语句 复用性好 12345678910111213const S = function(salary) { return salary * 4}const A = function(salary) { return salary * 3}const B = function(salary) { return salary * 2}const calculateBonus = function(func, salary) { return func(salary)}calculateBonus(A, 10000) 装饰者模式 为对象添加新功能 不改变其原有的结构和功能123456789101112131415161718function readonly(target, name, descriptor) { descriptor.wirteable = false;}class Person { constructor() { this.firstName = 'tony'; this.secondName = 'parker'; } @readonly name() { return this.firstName + this.secondName; }}const a = new Person();console.log(a.name());a.name = function() { }; // 修改name，报错 代理模式代理对象和本体对象具有一致的接口, 对使用者友好 发布订阅模式12345678910111213141516171819202122232425262728293031let event = { list: {}, on(key, fn) { if (!this.list[key]) { this.list[key] = [] } this.list[key].push(fn) }, emit() { let key = [].shift.call(arguments), fns = this.list[key] if (!fns || fns.length === 0) { return false } fns.forEach(fn =&gt; { fn.apply(this, arguments) }) }, remove(key, fn) { let fns = this.list[key] if (!fns) return false if (!fn) { fns &amp;&amp; (fns.length = 0) } else { fns.forEach((cb, index) =&gt; { if (fn === cb) { fns.splice(index, 1) } }) } }} 发布订阅者模式和观察者模式的区别？发布/订阅模式是观察者模式的一种变形，两者区别在于，发布/订阅模式在观察者模式的基础上，在目标和观察者之间增加一个调度中心。单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向。该模式存在不稳定性，发布者无法感知订阅者的状态。 观察者模式是由具体目标调度，比如当事件触发，Subject 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的。 发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。","link":"/2020/05/12/designPatterns/"},{"title":"基础算法","text":"排序算法及算法题目整合 冒泡排序12345678910111213141516function bubbleSort(arr) { if (arr === null || arr.length &lt; 2) return arr for (let i = 0; i &lt; arr.length; i++) { let isSort = false // 优化冒泡排序，表示此次循环没有进行交换，即待排序列已经有序，排序已然完成 for (let j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { isSort = true let temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } if (!isSort) break } return arr} 选择排序12345678910111213141516function selectSort(arr) { if (arr === null || arr.length &lt; 2) return arr for (let i = 0; i &lt; arr.length - 1; i++) { let index = i for (let j = i + 1; j &lt; arr.length; j++) { if (arr[index] &gt; arr[j]) { // 寻找最小值 index = j } } if (index !== i) { let temp = arr[index] arr[index] = arr[i] arr[i] = temp } }} 插入排序1234567891011121314function insertionSort(arr) { if (arr === null || arr.length &lt; 2) return arr let temp,j for (let i = 1; i &lt; arr.length; i++) { let temp = arr[i] let j = i while (j &gt; 0 &amp;&amp; arr[j-1] &gt; temp) { arr[j] = arr[j-1] j-- } arr[j] = temp } return arr} 快速排序1234567891011121314function quickSort(arr) { if (arr.length &lt; 2 || arr === null) return arr let pivotIndex = Math.floor(arr.length / 2) // 获取基准值的index let pivot = arr.splice(pivotIndex, 1) // 获取对应基准值 let left = [], right = [] for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; pivot) { left.push(arr[i]) } else { right.push(arr[i]) } } return [...quickSort(left), pivot, ...quickSort(right)]} 优化快速排序（原地排序）123456789101112131415161718function quickSort2(arr, left, right) { if (left &lt; right) { let pos = left - 1 // 定义一个pos指针 for (let i = left; i &lt;= right; i++) { let pivot = arr[right] if (arr[i] &lt;= pivot) { pos++ let swapItem = arr[pos] arr[pos] = arr[i] arr[i] = swapItem } } // 一趟排序完成后，pos位置即基准数的位置，以pos的位置左右分割数组 quickSort2(arr, left, pos - 1) quickSort2(arr, pos + 1, right) } return arr}还可以再优化1：当是有序数组时，取基准点时也顺序取，就可能导致基准点一侧的子数组一直为空2：数组中重复的数据比较多[1,2,2,2,2,2,2,7]，无论基准点取哪个值，都会导致基准点两侧数组大小不平衡, 影响快排效率 对于第一个问题, 我们可以通过在取基准点的时候随机化来解决，对于第二个问题，我们可以使用三路快排的方式来优化 归并排序1234567891011121314151617181920function mergeSort(arr) { if (arr.length &lt;= 1) return arr const midIndex = arr.length / 2 | 0 // 向下取整 const leftArr = arr.slice(0, midIndex) const rightArr = arr.slice(midIndex, arr.length) return merge(mergeSort(leftArr), mergeSort(rightArr))}function merge(leftArr, rightArr) { let result = [] while (leftArr.length &amp;&amp; rightArr.length) { if (leftArr[0] &lt;= rightArr[0]) { result.push(leftArr.shift()) } else { result.push(rightArr.shift()) } } while(leftArr.length) result.push(leftArr.shift()) while(rightArr.length) result.push(rightArr.shift()) return result} 洗牌算法12345678910function shuffle(arr) { if (arr === null || arr.length &lt; 2) return arr for (let i = 0 ; i &lt; arr.length; i++) { let index = Math.floor(Math.random() * (i + 1)) let temp = arr[index] arr[index] = arr[i] arr[i] = temp } return arr} 斐波那契数列1234567891011121314151617181920212223242526272829303132333435363738394041424344// 普通递归版function fib1(n) { if (typeof n !== \"number\") { throw new Error(\"..\"); } if (n &lt; 2) return n; return fib1(n - 1) + fib1(n - 2);} // 尾调用 优化function fib2(n, a = 0, b = 1) { if (typeof n !== \"number\") { throw new Error(\"..\"); } if (n === 0) { return a; } return fib2(n - 1, b , a + b);}// 备忘录递归法const hashMap = {}function fib3(n) { if (typeof n !== \"number\") { throw new Error(\"..\"); } if (n &lt; 2) return n; if (hashMap[n]) { return hashMap[n]; } const value = fib3(n - 1) + fib3(n - 2); hashMap[n] = value; return value}// 动态规划function fib4(n) { if (typeof n !== \"number\") { throw new Error(\"..\"); } if (n &lt; 2) return n; let a = 0, b = 1; while (n--) { [a, b] = [b, a+b]; } return a} LRU算法(Least Recently Used ：最近最少使用)","link":"/2019/06/10/algorithm/"},{"title":"Git","text":"Git常用命令 创建并切换到新分支1git checkout -b newBranch更新提交分支代码123git add .git commit -m'update'git push版本回退123git revert -n 版本号git commit -m'update'git push强制回退12git reset --hard 版本号git push -f -u origin master初始化git123456git init //在当前的项目目录中生成本地的git管理git add . //将文件保存到缓存区,git add -A 将增、删、改的文件改动全保存至缓存区git commit -m &quot;描述&quot; //将代码从缓存区保存至本地仓库git remote add origin https://仓库地址.git //将本地仓库与指定的远程仓库联系,origin是仓库名字，可以改git push -u origin master //将本地仓库代码推送至远程仓库当git无法添加某文件夹下文件时123//directory为子文件夹的路径git rm --cached directorygit add directory执行git rm –cached directory时若提示1fatal: Unable to create 'xx/.git/index.lock': File exists.则执行1rm -f xx/.git/index.lock git命令指南","link":"/2019/01/16/git/"},{"title":"note","text":"… 1.offsetleft offsettop3.输入url到页面展示 发生了什么4.返回字符串的最长不重复子串长度5.flex 1 = flex grow 1 flex shrink 1 flex basic 0%6.浏览器渲染也页面过程7.手写 bind、reduce8.webpack 的 require 是如何查找依赖的9.webpack 如何实现动态加载10.cookie新属性11.dillPlugin13.css3三角形14.new function执行函数15.项目中哪里使用了闭包，闭包如何引起内存泄漏16.前端埋点，错误收集，页面白屏和加载时间收集17.node转发实现","link":"/2020/07/08/note/"},{"title":"Hexo + Icarus + Github 搭建个人站点","text":"本文将基于Hexo构建博客网站，替换theme主题为Icarus，最后通过Github部署发布，这样可以通过Github分发的网站链接进行访问，当然也可以自己购买域名和服务器进行部署，但此文暂时不涉及这部分内容 1.准备工作安装Node下载 Node.js，按照步骤安装即可。 安装Git下载 Git，同样按照步骤安装即可。 注册GitHub 如果部署在自己的服务器可以忽略这步，并不影响Hexo的使用 注册 GitHub，已有的默认请忽略 2.安装使用Hexo安装和初始化Node 和 Git 都安装好后，可执行以下命令安装hexo1npm install hexo -g然后执行初始化1hexo init &lt;文件名&gt;或者可以cd到指定目录下，直接执行 hexo init 目录介绍1234567891011.├── .deploy //执行hexo deploy命令部署到GitHub上的内容目录├── public //执行hexo generate命令，输出的静态网页内容目录├── scaffolds //layout模板文件目录，其中的md文件可以添加编辑├── scripts //扩展脚本目录，这里可以自定义一些javascript脚本├── source //文章源码目录，该目录下可新建页面目录| ├── _drafts //草稿文章| └── _posts //发布文章├── themes //主题文件目录├── _config.yml //全局配置文件└── package.json //应用程序数据，指明hexo的版本等信息 本地启动安装并执行完初始化后，可以执行以下命令，启动本地服务，预览界面1hexo server浏览器输入 http://localhost:4000 就可以看到效果了 写文章执行以下new命令，会自动生成指定名称的文章1hexo new &lt;文章名&gt;我们可以看一下生成的文件 文件名\\source\\ _posts\\文章名.md123456title: 文章名 #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2018-12-22 18:33:58 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格---这里开始使用markdown格式输入你的正文如果你想使用文章的摘要功能，只需要添加即可12345678title: 文章名 date: 2018-12-22 18:33:58 categories: Hexotags: tag1---我是摘要，在主页显示&lt;!--more--&gt;下面是文章余下的内容，不在主页显示more以上内容即是文章摘要，在主页显示，more以下内容点击Read More链接打开全文才显示。 在文件名\\source\\ _posts\\下手动生成一个.md文件也是可以的 关于写作的模板用法或其他相关可以参考 Hexo文档 本文只记录主要步骤 3.更换主题Hexo的社区提供了200多个主题，你可以挑选自己喜欢的clone下来使用，Hexo主题 推荐两款，Next是比较受追捧的一款，Apollo我个人认为是一款简洁易扩展定制的，有兴趣可以看一下 我这边最终用的是 Icarus 作为设计师出身的我必须对这款主题的作者表达敬意～ 安装主题安装主题的方法就是一句git命令1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 更改_config.yml文件将博客根目录下的_config.yml中的主题设置改为icarus1theme: icarus 运行本地服务最后，请使用如下命令来启动Hexo本地测试服务器，即可看见结果1hexo server 小tips1.修改主题为中文语言，修改的是Hexo目录下_config.yml的language，并不是theme文件下的_config.yml 2.主页文章的顶部展示图，需要在文章的头部添加 thumbnail123456title: 文章名 date: 2018-12-22 18:33:58 categories: Hexotags: tag1thumbnail: 'http://imagesUrl'--- 3.检索搜索功能如果出现混乱，比如删除新增过不同标签分类或文章，只要重新执行hexo clean + hexo generate即可 4.部署在GitHub 首先注册一个 GitHub 帐号，在第一步准备工作已经提到 注册帐号就不多啰嗦了 建立与你用户名对应的仓库，仓库名必须为&lt;your_user_name.github.com&gt; 首先 Create a new repository，新建一个仓库，名字为&lt;自己的用户名+github.io&gt; 添加SSH公钥到 Account settings -&gt; SSH Keys -&gt; Add SSH Key 打开cmd命令行或者鼠标右键git bash，设置你的用户名和密码，与GitHub一致12git config --global user.email &quot;xxx@163.com&quot;git config --global user.name &quot;xxx&quot;生成密钥，中间连续3次Enter键1ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; .ssh目录会生成id_rsa和id_rsa.pub两个文件，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 如果之前此电脑已经生成过密钥，根据提示在overwrite的时候选择 y 覆盖即可 点击页面顶部右边自己头像下的Settings，选择SSH and GPG keys，随后点击SSH一栏的New SSH key，title可以自行填写 最后可以验证一下,执行该命令，输入yes1$ ssh -T git@github.com 输出如下，则表示通过了1Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access. 上传Hexo到Github安装deployer插件npm如果安装失败，可以试试淘宝镜像cnpm1npm install –save hexo-deployer-git 修改Hexo文件下的_config.yml页面最下方，找到deploy1234deploy: type: git repo: github: https://github.com/你的用户名/你的用户名.github.io.git,master 执行发布命令记得每一次发布前，执行一次 hexo generate 命令，输出新的静态网页内容目录，再执行deploy1hexo deploy按要求输入GitHub的帐号密码 如下图的结果，表示发布成功，浏览器打开 &lt;你的用户名.github.io&gt; 查看结果 进阶内容添加评论评论功能使用的是 Valine ，我们需要先注册 LeanCloud 其次找到theme文件下的icarus中的config.yml文件 修改主题页面.git文件为隐藏文件同步themes主题下的文件至github 参考","link":"/2019/01/16/hexoBlog/"},{"title":"Nginx","text":"Nginx nginx正向代理、反向代理、负载均衡相关1.正向代理正向代理是为客户端服务的，通过代理客户端的请求，去访问客户端本身无法直接访问的服务器，翻墙工具就是最常见的正向代理。正向代理对于客户端透明，对于服务器端不透明。nginx配置示例：1234567891011121314server { resolver 8.8.8.8; #指定DNS服务器IP地址 listen 80; location / { proxy_pass http://$host; #设定代理服务器的协议和地址 proxy_set_header HOST $host; proxy_buffers 256 4k; proxy_max_temp_file_size 0k; proxy_connect_timeout 30; proxy_send_timeout 60; proxy_read_timeout 60; proxy_next_upstream error timeout invalid_header http_502; }} 2.反向代理反向代理是指为服务端服务的，反向代理接收来自客户端的请求，帮助服务器进行请求转发、负载均衡等。通常解决前端跨域问题也是通过反向代理实现的。反向代理对于服务端是透明的，对于客户端是不透明的。nginx配置示例：123456789server { listen 80; server_name xx.a.com; // 监听地址 location / { root html; proxy_pass xx.b.com; // 请求转向地址 index index.html; // 设置默认页 }} 3.负载均衡负载均衡是指nginx将大量客户端的请求合理地分配到各个服务器上，以达到服务端资源的充分利用和更快的响应请求。nginx配置示例：12345678910111213upstream balanceServer { server 1.1.2.3:80; server 1.1.2.4:80; server 1.1.2.5:80;}server { server_name xx.a.com; listen 80; location /api { proxy_pass http://balanceServer; }}常用的负载均衡策略： 轮询策略: 默认策略，遍历服务器节点列表，逐一分配请求，如果服务器down掉，自动剔除。 加权轮询: 每台服务器有不同的权重，一般权重越大意味着该服务器的性能越好，可以承载更多的请求。12345upstream balanceServer { server 1.1.2.3:80 weight=5; server 1.1.2.4:80 weight=10; server 1.1.2.5:80 weight=20;} 最小连接策略: 将请求优先分配给压力较小的服务器，避免压力大的服务器添加更多的请求。123456upstream balanceServer { least_conn; server 1.1.2.3:80; server 1.1.2.4:80; server 1.1.2.5:80;} 最快响应时间策略: 将请求有限分配给响应时间最短的服务器。123456upstream balanceServer { fair; server 1.1.2.3:80; server 1.1.2.4:80; server 1.1.2.5:80;} 客户端ip绑定: 将来自同一个ip的请求永远只分配给一台固定的服务器。123456upstream balanceServer { ip_hash; server 1.1.2.3:80; server 1.1.2.4:80; server 1.1.2.5:80;} 参考：前端开发者必备的 Nginx 知识nginx万字详解","link":"/2020/04/26/nginx/"},{"title":"Promise","text":"Promise.allSettled跟Promise.all类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态，而不管其是否处理成功。 依照PromiseA+规范 的Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210const PENDING = 'pending'const FULFILLED = 'fulfilled'const REJECTED = 'rejected'const resolvePromise = (promise, x, resolve, reject) =&gt; { if (x === promise) { // If promise and x refer to the same object, reject promise with a TypeError as the reason. reject(new TypeError('循环引用')) } // if x is an object or function, if (x !== null &amp;&amp; typeof x === 'object' || typeof x === 'function') { // If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored. let called try { // If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason. let then = x.then // Let then be x.then // If then is a function, call it with x as this if (typeof then === 'function') { // If/when resolvePromise is called with a value y, run [[Resolve]](promise, y) // If/when rejectPromise is called with a reason r, reject promise with r. then.call(x, y =&gt; { if (called) return called = true resolvePromise(promise, y, resolve, reject) }, r =&gt; { if (called) return called = true reject(r) }) } else { // If then is not a function, fulfill promise with x. resolve(x) } } catch (e) { if (called) return called = true reject(e) } } else { // If x is not an object or function, fulfill promise with x resolve(x) }}class Promise { constructor(executor) { this.status = PENDING this.value = undefined this.reason = undefined // 存放成功/失败的队列 this.onFulfilledCallbacks = [] this.onRejectedCallbacks = [] const resolve = (value) =&gt; { // 如果value是一个Promise 递归解析 if (value instanceof Promise) { return value.then(resolve, reject) } if (this.status === PENDING) { this.status = FULFILLED this.value = value this.onFulfilledCallbacks.forEach(fn =&gt; fn()) } } const reject = (reason) =&gt; { if (this.status === PENDING) { this.status = REJECTED this.reason = reason this.onRejectedCallbacks.forEach(fn =&gt; fn()) } } try { executor(resolve, reject) // 立即执行 } catch (error) { reject(error) } } then(onFulfilled, onRejected) { // 判断 onFulfilled, onRejected 是否是函数 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason } let newPromise = new Promise((resolve, reject) =&gt; { if (this.status === FULFILLED) { setTimeout(() =&gt; { try { let x = onFulfilled(this.value) resolvePromise(newPromise, x, resolve, reject) } catch (error) { reject(error) } }) } if (this.status === REJECTED) { setTimeout(() =&gt; { try { let x = onRejected(this.reason) resolvePromise(newPromise, x, resolve, reject) } catch (error) { reject(error) } }) } if (this.status === PENDING) { this.onFulfilledCallbacks.push((() =&gt; { setTimeout(() =&gt; { try { let x = onFulfilled(this.value) resolvePromise(newPromise, x, resolve, reject) } catch (error) { reject(error) } }) })) this.onRejectedCallbacks.push(() =&gt; { setTimeout(() =&gt; { try { let x = onRejected(this.reason) resolvePromise(newPromise, x, resolve, reject) } catch (error) { reject(error) } }) }) } }) return newPromise } /** * Promise.catch * @description 用于promise方法链示，捕获前面 onFulfilled/onRejected 抛出的异常 * @param {*} errorCallback */ catch(errorCallback) { return this.then(null, errorCallback) } /** * Promise.finally * @description finally 传入的函数 无论成功和失败都执行 * @param {*} callback 回调函数 * @returns 返回成功/失败 */ finally(callback) { return this.then((value) =&gt; { // 返回上一次的值 return new Promise(callback()).then(() =&gt; value) }, error =&gt; { return new Promise(callback()).then(() =&gt; { throw error }) }) } /** * Promise.all * @description 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve 当有一个promise对象变为reject状态时 直接 reject * @param {*} values promise对象组成的数组作为参数 * @returns 返回一个promise实例 */ static all(values) { return new Promise((resolve, reject) =&gt; { let resultArr = [] let count = 0 const resultArrByKey = (index, value) =&gt; { resultArr[index] = value if (++count === values.length) { resolve(resultArr) } } values.forEach((promise, index) =&gt; { promise.then((value) =&gt; { resultArrByKey(index, value) }, reject) }) }) } /** * Promise.race * @description 只要有一个promise对象进入FULFILLED 或者 REJECTED 状态的话，就会继续执行后面的处理 * @param {*} values 接受promise对象组成的数组作为参数 * @returns 返回一个Promise实例 */ static race(values) { return new Promise((resolve, reject) =&gt; { values.forEach((promise) =&gt; { promise.then(resolve, reject) }) }) } // 默认产生一个成功的promise static resolve(value) { return new Promise((resolve, reject) =&gt; { resolve(value) }) } // 默认产生一个失败的promise static reject(reason) { return new Promise((resolve, reject) =&gt; { reject(reason) }) }}Promise.deferred = () =&gt; { let defer = {} defer.promise = new Promise((resolve, reject) =&gt; { defer.resolve = resolve defer.reject = reject }) return defer}module.exports = Promise","link":"/2020/04/16/promise/"},{"title":"Node","text":"Node.js相关 单线程基础概念： 进程：进程（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。 线程：线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。 协程：协程（英语：coroutine），又称微线程，是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的，各个线程如下： 主线程：编译、执行代码。 编译/优化线程：在主线程执行的时候，可以优化代码。 分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。 垃圾回收的几个线程。 事件循环123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 注意：每个框被称为事件循环机制的一个阶段。 阶段概述： 定时器 ：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。 待定回调 ：执行延迟到下一个循环迭代的 I/O 回调。 idle, prepare ：仅系统内部使用。 轮询 ：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。 检测 ：setImmediate() 回调函数在这里执行。 关闭的回调函数 ：一些关闭的回调函数，如：socket.on(‘close’, …)。 在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。","link":"/2019/06/09/node/"},{"title":"常用工具类函数","text":"","link":"/2020/04/09/utils/"},{"title":"Vue3","text":"Vue3 compositon api 与 2.x 版本生命周期相对应的组合式 APIbeforeCreate -&gt; 使用 setup()created -&gt; 使用 setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured 新增的钩子函数onRenderTrackedonRenderTriggered","link":"/2020/06/12/vue3/"},{"title":"webpack","text":"webpack webpack如何打包优化先使用webpack-bundle-analyzer分析打包后整个项目中的体积结构，既可以看到项目中用到的所有第三方包，又能看到各个模块在整个项目中的占比。 1.按需加载1.1 路由按需加载Vue中路由懒加载，使用() =&gt; import(xxx.vue)形式，打包会根据路由自动拆分打包。1.2 第三方库按需加载尽量按需加载，避免把整个库打包到项目中去。 2.文件解析优化loader解析优化：通过配置include和exclude来减少被处理的文件，还可以配合cacheDirectory来缓存编译后的结果。123456789101112module: { rules: [ { test: /\\.js$/, loader: 'babel-loader?cacheDirectory', include: [ path.resolve(__dirname, 'src') ], exclude: /node_modules/ } ]} 文件解析优化：通过配置resolve选项中的alias、extensions、modules来实现。alias：创建import或require的别名，加快webpack查找速度。extensions：自动解析确定的扩展，尽可能减少后缀尝试的可能性，默认值为：1extensions: [\".js\", \".json\"]modules：解析模块时应该搜索的目录，通常建议使用绝对路径，避免层层查找祖先目录。12345678resolve: { alias: { '@': path.resolve(__dirname, \"src\") }, extensions: [\".js\", \".vue\"], mainFields: [\"index\", \"main\"], modules: [path.resolve(__dirname, \"src\"),\"node_modules\"]} 3.拆分公共模块使用splitChunks进行拆包，抽离公共模块。splitChunks默认配置如下：1234567891011121314151617181920212223242526272829splitChunks: { // 表示选择哪些 chunks 进行分割，可选值有：async(按需加载)，initial(直接引用)和all chunks: \"async\", // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。 minSize: 30000, // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。 minChunks: 1, // 表示按需加载文件时，并行请求的最大数目。默认为5。 maxAsyncRequests: 5, // 表示加载入口文件时，并行请求的最大数目。默认为3。 maxInitialRequests: 3, // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js automaticNameDelimiter: '~', // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。 name: true, // cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。 cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10 }, // default: { minChunks: 2, priority: -20, reuseExistingChunk: true } }}总结下来就是： 被复用代码或者来自node_moules文件夹中的模块 模块的体积大小必须大于等于30kb才进行拆分 当按需加载chunks时，并行请求的最大数量不能超过5 初始页面加载时，并行请求的最大数量不能超过3 下面就是把node_modules中的react和moment再进行拆分，避免打包出的vendor包过大。1234567891011121314151617181920212223242526272829splitChunks: { chunks: 'all', minSize: 30000, minChunks: 1, cacheGroups: { lib: { name: 'vendors', test: /[\\\\/]node_modules[\\\\/]/, priority: 10, chunks: 'initial' // 只打包初始时依赖的第三方 }, react: { name: 'react', // 单独将 react 拆包 priority: 20, test: /[\\\\/]node_modules[\\\\/]react[\\\\/]/, chunks: 'all' }, moment: { name: 'moment', //单独将moment拆包 priority: 20, test: /[\\\\/]node_modules[\\\\/]moment[\\\\/]/ }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true } }} 4.DllPlugin和DllReferencePlugin通常打包过程中，由于第三方库代码不经常改变，我们可以将第三方库的代码跟业务代码抽离，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。DllPlugin 和 DLLReferencePlugin 可以实现拆分 bundles，并且可以大大提升构建速度，DllPlugin 和 DLLReferencePlugin 都是 webpack 的内置模块。 配置webpack.dll.js，将lodash、jquery、antd抽离出来。123456789101112131415161718192021222324const path = require(\"path\");const webpack = require(\"webpack\");const {CleanWebpackPlugin} = require(\"clean-webpack-plugin\");module.exports = { mode: \"production\", entry: { lodash: [\"lodash\"], jquery: [\"jquery\"], antd: [\"antd\"] }, output: { filename: \"[name].dll.js\", path: path.resolve(__dirname, \"dll\"), library: \"[name]\" // name和library保持一致 }, plugins: [ new CleanWebpackPlugin(), new webpack.DllPlugin({ name: \"[name]\", path: path.resolve(__dirname, \"manifest/[name].manifest.json\") }) ]};配置package.json中，新增script打包dll1234&quot;scripts&quot;: { ..., &quot;dll&quot;: &quot;webpack --config webpack.dll.js&quot;}执行npm run dll，生成dll文件和对应的manifest.json。 将打包的dll通过add-asset-html-webpack-plugin添加到html中，再通过DllReferencePlugin把dll引用到需要编译的依赖。 配置webpack.config.js：12345678910111213141516const manifests = ['antd', 'jquery', 'lodash'];const dllPlugins = manifests.map(item =&gt; { return new webpack.DllReferencePlugin({ manifest: require(`./manifest/${item}.manifest`) });});module.exports = { ..., plugins: [ ...dllPlugins, new AddAssetHtmlPlugin({ filepath: path.resolve(__dirname, \"./dll/*.dll.js\") }) ]} 5.开启多线程压缩使用 terser-webpack-plugin 开启多线程压缩PS：构建时可以使用 thread-loader，会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建1234567module.exports = { optimization: { minimizer: [new TerserPlugin( parallel: true // 多线程 )], },}; 6.speed-measure-webpack-plugin简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。 hash chunkhash contenthash 区别hashhash是跟整个项目的构建相关，构建生成的文件hash值都是一样的，所以hash计算是跟整个项目的构建相关，同一次构建过程中生成的hash都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。如果出口是hash，那么一旦针对项目中任何一个文件的修改，都会构建整个项目，重新获取hash值，缓存的目的将失效。 chunkhashchunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成hash值，那么只要我们不改动公共库的代码，就可以保证其hash值不会受影响。由于采用chunkhash，所以项目主入口文件main.js及其对应的依赖文件main.css由于被打包在同一个模块，所以共用相同的chunkhash，但是公共库由于是不同的模块，所以有单独的chunkhash。这样子就保证了在线上构建时只要文件内容没有更改就不会重复构建。 contenthashcontenthash表示由文件内容产生的hash值，内容不同产生的contenthash值也不一样。在项目中，通常做法是把项目中css都抽离出对应的css文件来加以引用。 (webpack相关优化)[https://github.com/lgwebdream/FE-Interview/issues/25]","link":"/2020/06/12/webpack/"},{"title":"Vue","text":"Vue Vue的优点及缺点响应式：这也就是vue.js最大的优点，通过MVVM思想实现数据的双向绑定，通过虚拟DOM让我们可以用数据来操作DOM，而不必去操作真实的DOM，提升了性能。且让开发者有更多的时间去思考业务逻辑。 组件化：把一个单页应用中的各个模块拆分到一个个组件当中，或者把一些公共的部分抽离出来做成一个可复用的组件。所以组件化带来的好处就是，提高了开发效率，方便重复使用，使项目的可维护性更强。 缺点： 不利于seo。 导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。 初次加载时耗时多。 Vue Router完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 对MVVM的理解MVVM 模式，顾名思义即 Model-View-ViewModel 模式。Model 层: 对应数据层的域模型，它主要做域模型的同步。View 层: 作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。ViewModel 层: 把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。 MVVM优点1.分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑2.提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码3.自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放 MVVM缺点1.Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的2.一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存 vuexvuex的流向： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作） state 定义了应用状态的数据结构，可以在这里设置默认的初始状态mutations 同步操作，更改store状态,通过commit显示触发actions 用于提交 mutation，而不是直接变更状态，可以包含任意异步操作，通过dispatch分发Module 允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中Getter store的计算属性，返回值会根据它的依赖被缓存起来，处理一些比较复杂的函数 Vue初始化流程 创建Vue实例对象 init过程会初始化生命周期，初始化事件中心，初始化渲染、执行beforeCreate周期函数、初始化 data、props、computed、watcher、执行created周期函数等。 初始化后，调用$mount方法对Vue实例进行挂载（挂载的核心过程包括模板编译、渲染以及更新三个过程）。 如果没有在Vue实例上定义render方法而是定义了template，那么需要经历编译阶段。需要先将template 字符串编译成 render function，template 字符串编译步骤如下 ： parse正则解析template字符串形成AST（抽象语法树，是源代码的抽象语法结构的树状表现形式） optimize标记静态节点跳过diff算法（diff算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有O(n)。如果对于时间复杂度不是很清晰的） generate将AST转化成render function字符串 编译成render function 后，调用$mount的mountComponent方法，先执行beforeMount钩子函数，然后核心是实例化一个渲染Watcher，在它的回调函数（初始化的时候执行，以及组件实例中监测到数据发生变化时执行）中调用updateComponent方法（此方法调用render方法生成虚拟Node，最终调用update方法更新DOM）。 调用render方法将render function渲染成虚拟的Node（真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。如果频繁的去做 DOM 更新，会产生一定的性能问题，而 Virtual DOM 就是用一个原生的 JavaScript 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多，而且修改属性也很轻松，还可以做到跨平台兼容），render方法的第一个参数是createElement(或者说是h函数)，这个在官方文档也有说明。 生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用pacth方法把虚拟DOM转换成真正的DOM节点。需要注意在图中忽略了新建真实DOM的情况（如果没有旧的虚拟Node，那么可以直接通过createElm创建真实DOM节点），这里重点分析在已有虚拟Node的情况下，会通过sameVnode判断当前需要更新的Node节点是否和旧的Node节点相同（例如我们设置的key属性发生了变化，那么节点显然不同），如果节点不同那么将旧节点采用新节点替换即可，如果相同且存在子节点，需要调用patchVNode方法执行diff算法更新DOM，从而提升DOM操作的性能。 Vue双向绑定原理Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 Vue响应式原理 在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。 当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。 Vue的数据为什么频繁变化但只会更新一次Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。另外，关于waiting变量，这是很重要的一个标志位，它保证flushSchedulerQueue回调（$nextTick中执行）允许被置入callbacks一次。因为Vue的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：现在有这样的一种情况，mounted的时候test的值会被循环执行++1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个queue队列，在下一个tick（或者是当前tick的微任务阶段）统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick（或者是当前tick的微任务阶段）的时候调用，大大优化了性能。执行顺序update -&gt; queueWatcher -&gt; 维护观察者队列（重复id的Watcher处理） -&gt; waiting标志位处理（保证需要更新DOM或者Watcher视图更新的方法flushSchedulerQueue只会被推入异步执行的$nextTick回调数组一次） -&gt; 处理$nextTick（在为微任务或者宏任务中异步更新DOM）-&gt; Vue是异步更新Dom的，Dom的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行 由于VUE的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM完成更新，立即执行nextTick(callback)内的回调。 虚拟 Dom 实现原理虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 (Vue核心之虚拟DOM)[https://juejin.im/post/5d36cc575188257aea108a74] Vue2.x和Vue3.x渲染器的diff算法分别说一下简单来说，diff算法有以下过程 同级比较，再比较子节点 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除) 比较都有子节点的情况(核心diff)递归比较子节点 正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -&gt; O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。 Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。 Vue3.x借鉴了ivi算法和inferno算法在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。 路由守卫全局前置守卫注意一定要调用 next(); ，否则钩子就不会被 resolved。12345const router = new VueRouter({ ... })router.beforeEach((to, from, next) =&gt; { // ... next();}) 全局解析守卫在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：123router.afterEach((to, from) =&gt; { // ...}) 路由独享的守卫你可以在路由配置上直接定义 beforeEnter 守卫：1234567891011const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } } ]}) 组件内的守卫最后，你可以在路由组件内直接定义以下路由导航守卫： beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave注意要调用 next()123456789101112131415161718const Foo = { template: `...`, beforeRouteEnter (to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` }} Vue 的父组件和子组件生命周期钩子函数执行顺序Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程父 beforeUpdate -&gt; 父 updated 销毁过程父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed hash / history 两种模式有什么区别 hash模式1.原理：hash模式是依靠onhashchange事件(监听location.hash的改变)2.优点： (1) 只需要前端配置路由表, 不需要后端的参与 (2) 兼容性好, 浏览器都能支持 (3) hash值改变不会向后端发送请求, 完全属于前端路由3.缺点： (1) hash值前面需要加#, 不符合url规范,也不美观 history模式1.原理：history模式是主要是依靠的HTML5 history中新增的两个方法(监听window.onpopstate) pushState()可以改变url地址且不会发送请求 replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改2.优点： (1) 符合url地址规范, 不需要#, 使用起来比较美观3.缺点： (1) 当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持；因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如www.xxx.com/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面 (2) 兼容性比较差, 是利用了 HTML5 History对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持. (30 道 Vue 面试题)[https://juejin.im/post/5d59f2a451882549be53b170]","link":"/2020/04/26/vue/"},{"title":"前端面试题（手写）","text":"前端面试题，手撸方向 解析url的参数123456789101112//尽可能全面正确的解析一个任意url的所有参数为Objectvar url = 'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled';parseParam(url);/**结果：{ user: 'anonymous', id: [123, 456], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city: '北京', // 中文 enabled: true, // 未指定值的 key 约定值为 true}*/ 解答：123456789101112131415161718192021function parseParam(url){ let num = url.indexOf('/?') //得到url中'/?'字符的index let urlStr = url.substring(num+2) //取出url'/?'后的字符 let urlArr = urlStr.split('&amp;') //以'&amp;'分割字符串，存储到数组中 let paramsObj = {} urlArr.forEach(item =&gt; { //遍历数组 if (item.indexOf('=') != -1) { //判断是否有对应的value，即是否有'=' let [key,val] = item.split('=') //解构赋值，分割key和value val = decodeURIComponent(val) //解码，转换为中文 if (paramsObj.hasOwnProperty(key)) { //判断paramsObj是否已有对应的key paramsObj[key] = [].concat(paramsObj[key],val) //有的话就转换为数组合并 }else{ //没有的话就直接以对象存储 paramsObj[key] = val } }else{ // 处理没有value的，默认约定值为true paramsObj[item] = true } }) console.log(paramsObj)}parseParam(url) 实现一个JSONP12345678910111213141516171819202122function JSONP(url, params, callbackKey, callback) { params = params || {} params[callbackKey] = 'jsonpCallback' window.jsonpCallback = callback // 拼接参数字符串 const paramsKey = Object.keys(params) const paramsString = paramsKey.map(key =&gt; `${key}=${params[key]}`).join('&amp;') // 插入 DOM 元素 const script = document.createElement('script') script.setAttribute('src', `${url}?${paramsString}`) document.body.appendChild(script)}JSONP({ url: 'http://demo.com/ajax/jsonp/suggestion', params: { key: 'test', }, callbackKey: '_cb', callback(result) { console.log(result.data) }}) 实现一个简单的模板引擎123456let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';let data = { name: '姓名', age: 18}render(template, data); // 我是姓名，年龄18，性别undefined 解答： 普通方式12345678910function render(template, data){ const reg = /\\{\\{(\\w+)\\}\\}/ //模板字符串的正则表达式 if(reg.test(template)){ //模板中是否有相关字符串 let name = reg.exec(template)[1] //查找模板中的第一个字符串的name template = template.replace(reg,data[name]) //将模板中的字符串替换为data对应的值 return render(template,data) //递归调用并渲染余下字符串 } console.log(template) return template //如果没有模板字符串就直接返回} 一行代码实现方式123function render(template, data) { return template.replace(new RegExp('{{(.*?)}}', 'g'), (match, key) =&gt; data[key.trim()])} 将一个任意长的数字变成逗号分隔的格式12// 1234.56 =&gt; \"1,234.56\" , 123456789 =&gt; \"123,456,789\"parseToMoney(1234.56) // return \"1,234.56\" 解答：123456789function parseToMoney(num) { num += '' //转换为字符串 let [integer,decimal] = num.split('.') //转换为整数和小数的数组 integer = integer.replace(/\\d(?=(\\d{3})+$)/g, '$&amp;,') //整数部分利用正则判断每三位数插入一个逗号 return integer + (decimal ? '.' + decimal : '') //最后判断是否有小数部分进行拼接}function parseToMoney2(num) { return num.toLocaleString()} 数据绑定的最基本实现1234567891011// 实现一个方法，可以给 obj 所有的属性添加动态绑定事件，当属性值发生变化时会触发事件let obj = { key_1: 1, key_2: 2}function func(key) { console.log(key + ' 的值发生改变：' + this[key]);}bindData(obj, func);obj.key_1 = 2; // 此时自动输出 \"key_1 的值发生改变：2\"obj.key_2 = 1; // 此时自动输出 \"key_2 的值发生改变：1\" 解答：123456789101112131415function bindData(obj,func){ for(let key in obj){ Object.defineProperty(obj,key,{ set(newVal){ if (this.value !== newVal) { this.value = newVal func.call(obj,key) } }, get(){ return this.value } }) }} 递归找文件12345678// 现提供几个读取文件的方法，不借助全局变量实现一个函数，函数可以执行一次后返回一个目录下所有文件中是 .js 后缀的文件列表var readdirSync = function(dir_path){ return [filename] } // 读取一个文件夹下的所有文件夹和文件的路径列表（Array）var isDirectory = function(path) { return true/false; } // 判断一个路径是否是文件夹var existsSync = function(path){ return true/false;} // 判断一个文件/文件夹是否存在var getJSFiles = function(path) { }getJSFiles('/code/'); // return 一个文件列表的数组 解答:1234567891011121314function getJSFiles(path) { var result = []; if(existsSync(path)) { //判断文件/文件夹是否存在 if(isDirectory(path)) { //是否是文件夹 var files = readdirSync(path); //获取文件夹下的文件和文件夹列表 files.forEach((file) =&gt; { //遍历文件和文件夹 result = result.concat(getJSFiles(file)); //递归调用 }); } else if(/\\.js$/.test(path)) { //正则判断.js后缀文件 result.push(path); //js文件插入数组 } } return result; //返回结果} 转换数字到中文大写12345678910111213141516function toLowerNum(n) { if (!/^(0|[1-9]\\d*)(\\.\\d+)?$/.test(n)){ //利用正则判断是否合规 return \"数据非法\" } let unit = \"千百拾亿千百拾万千百拾元角分\", str = \"\" //声明中文基和返回字符串 n += \"00\" //将数字转换为字符串并添加角分 let p = n.indexOf('.') //判断是否本身就有角分位 if (p &gt;= 0){ //有角分位 n = n.substring(0, p) + n.substr(p+1, 2) //重新截取数字，将小数点和拼接的'00'的去除 } unit = unit.substr(unit.length - n.length) //按照数字的长短截取中文基，这是关键需要理解 for (var i=0; i &lt; n.length; i++){ str += '零壹贰叁肆伍陆柒捌玖'.charAt(n.charAt(i)) + unit.charAt(i) //将阿拉伯数字转换成中文数字，按位添加中文基 } return str.replace(/零(千|百|拾|角)/g, \"零\").replace(/(零)+/g, \"零\").replace(/零(万|亿|元)/g, \"$1\").replace(/(亿)万|壹(拾)/g, \"$1$2\").replace(/^元零?|零分/g, \"\").replace(/元$/g, \"元整\") //利用正则替换语义不恰当的中文基} 实现一个函数，可以判断a字符串是否被包含在b字符串中不能用原生api，自己实现一个字符串查找，这道题其实非常经典参考 - KMP算法–转1234a='34';b='1234567'; // 返回 truea='35';b='1234567'; // 返回 falsea='355';b='12354355'; // 返回 trueisContain(a,b);解答：12345678910111213141516function isContain(a,b){ for(let i in b){ //遍历字符串b if (a[0] === b[i]) { //在字符串b上找到字符串a的第一个字符 let tmp = true //设置一个变量，默认true for(let j in a){ //遍历字符串a if (a[j] !== b[~~i + ~~j]) { //判断字符串a接下去字符是否有与b字符串相同（~~这里是快速将i和j转为数字进行运算） tmp = false //如果有不相同，则变量赋值false，默认为true } } if (tmp) { //通过遍历a字符串返回的结果，确认b中是否有a return true //有则返回true } } } return false //没有结果，返回false} 函数柯理化12345678910111213141516function curry(fn) { // 缓存除函数fn之外的所有参数 let args = Array.prototype.slice.call(arguments, 1) return function() { // 连接已缓存的老的参数和新传入的参数(即把每次传入的参数全部先保存下来，但是并不执行) let newArgs = args.concat(Array.from(arguments)) if (newArgs.length &lt; fn.length) { // 累积的参数总数少于fn形参总数 // 递归传入fn和已累积的参数 return curry.call(this, fn, ...newArgs) } else { // 调用 return fn.apply(this, newArgs) } }} compose组合函数123456789101112131415161718192021var greeting = (name) =&gt; `Hello ${name}`var toUpper = (str) =&gt; str.toUpperCase()var fn = compose(toUpper, greeting)console.log(fn('panson')) // HELLO PANSON function compose(...args) { var length = args.length // args函数的个数 var count = length - 1 var result return function func(...args1) { // func函数的args1参数枚举 result = args[count].apply(this, args1) if (count &gt; 0) { count -- return func.call(null, result) // result 上一个函数的返回结果 } else { count = length - 1 return result } }} 手动实现instanceof1234567891011121314151617181920212223function myInstanceof(left, right) { // 判断数据类型直接返回false if (typeof left !== 'object' || left === null) return false //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象 let proto = Object.getPrototypeOf(left) while (true) { if (proto == null) return false if (proto == right.prototype) return true proto = Object.getPrototypeOf(proto) }}function instanceOf2(L, R) { //L 表示左表达式，R 表示右表达式 var O = R.prototype; // 取 R 的显示原型 L = L.__proto__; // 取 L 的隐式原型 while (true) { if (L === null) return false; if (O === L) // 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; }} 数组扁平化1let array = [1, [2, [3, [4, 5]]], 6] //输出[1, 2, 3, 4, 5, 6] 1234567891011121314151617181920212223242526//ES6中的flat方法array = array.flat(Infinity)//replace + splitarray = JSON.stringify(array).replace(/(\\[|\\])/g, '').split(',')//普通递归let result = []function fn(array) { for(let i = 0; i &lt; array.length; i++) { let item = array[i] if (Array.isArray(item)) { fn(item) } else { result.push(item) } }}//利用reduce函数迭代function flatten(array) { return array.reduce((pre, cur) =&gt; { return pre.concat(Array.isArray(cur) ? flatten(cur) : cur) }, [])}//扩展运算符while (array.some(Array.isArray)) { array = [].concat(...array)} 实现数组map方法12345678910111213141516171819202122232425262728293031323334353637383940Array.prototype.map = function(callbackFn, thisArg) { // 处理数组类型异常 if (this === null || this === undefined) { throw new TypeError('Cannot read property 'map' of null or undefined') } // 处理回调类型异常 if (Object.prototype.toString.call(callbackFn) !== '[object Function]') { throw new TypeError(callbackfn + ' is not a function') } // 草案中提到要先转换为对象 let O = Object(this) let T = thisArg let len = O.length &gt;&gt;&gt; 0 let A = new Array(len) for (let k = 0; k &lt; len; k++) { if (k in O) { let kValue = O[k] // 依次传入this, 当前项，当前索引，整个数组 let mappedValue = callbackFn.call(T, KValue, k, O) A[k] = mappedValue } } return A}function map(arr, mapCallback) { // 首先，检查传递的参数是否正确。 if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { return []; } else { let result = []; // 每次调用此函数时，我们都会创建一个 result 数组 // 因为我们不想改变原始数组。 for (let i = 0, len = arr.length; i &lt; len; i++) { result.push(mapCallback(arr[i], i, arr)); // 将 mapCallback 返回的结果 push 到 result 数组中 } return result; }} 实现一个new方法12345678910111213141516171819function myNew(fn, ...args) { if (typeof fn !== 'function') { throw 'myNew function the first param must be a function' } let obj = Object.create(fn.prototype) let res = fn.apply(obj, args) let isObject = typeof res === 'object' &amp;&amp; res !== null let isFunction = typeof res === 'function' return isObject || isFunction ? res : obj}var New = function(Fn) { var obj = {}; // 创建空对象 var arg = Array.prototype.slice.call(arguments, 1); obj.__proto__ = Fn.prototype; // 将obj的原型链__proto__指向构造函数的原型prototype obj.__proto__.constructor = Fn; // 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn Fn.apply(obj, arg); // 执行Fn，并将构造函数Fn执行obj return obj; // 返回结果}; 实现一个call1234567891011121314151617Function.prototype.myCall = function(context) { // 判断调用对象 if (typeof this !== \"function\") { console.error(\"type error\"); } // 获取参数 let args = [...arguments].slice(1), result = null // 判断 context 是否传入，如果未传入则设置为 window context = context || window // 将调用函数设为对象的方法 context.fn = this // 调用函数 result = context.fn(...args) // 将属性删除 delete context.fn return result} 实现一个apply1234567891011121314151617181920Function.prototype.myApply = function(context) { // 判断调用对象 if (typeof this !== \"function\") { console.error(\"type error\"); } let result =null // 判断 context 是否存在，如果未传入则为 window context = context || window // 将函数设为对象的方法 context.fn = this // 调用方法 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } // 将属性删除 delete context.fn return result} 实现一个bind方法1234567891011121314151617181920Function.prototype.myBind = function(context) { // 判断调用对象是否为函数 if (typeof this !== \"function\") { throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fbound = function () { // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。 self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))); } fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;} 实现一个reduce方法1234567891011121314function reduce(arr, reduceCallback, initialValue) { if (!Array.isArray(arr) || arr.length === 0 || typeof reduceCallback !== 'function') { return [] } else { // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue let hasInitialValue = initialValue !== undefined let value = hasInitialValue ? initialValue : arr[0] // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始 for (let i = hasInitialValue ? 0 : 1; i &lt; arr.length; i++) { value = reduceCallback(value, arr[i], i, arr) } return value }} 实现一个Promise1234567891011121314151617181920212223242526272829303132333435function myPromise(constructor) { let self = this self.status = 'pending' self.value = undefined self.reason = undefined function resolve(value) { if (self.status === 'pending') { self.value = value self.status = 'resolved' } } function reject(reason) { if (self.status === 'pending') { self.reason = reason self.status = 'rejected' } } try { constructor(resolve, reject) } catch { reject(e) }}myPromise.prototype.then = function(onFullfilled, onRejected) { let self = this switch(self.status) { case 'resolved': onFullfilled(self.value) break case 'rejected': onRejected(self.reason) break default }} 实现一个Promise.all123456789101112131415161718192021function promiseAll(promises) { if (!Array.isArray(promises)) { throw new TypeError(`argument must be a array`) } return new Promise(function(resolve, reject) { let resolvedCount = 0 let promiseNum = promises.length let resolvedResult = [] for (let i = 0; i &lt; promiseNum; i++) { Promise.resolve(promises[i]).then(value =&gt; { resolvedCount++ resolvedResult[i] = value if (resolvedCount === promiseNum) { return resolve(resolvedResult) } },error =&gt; { return reject(error) }) } })} 深拷贝简单版 1234567891011121314151617function isObject(obj) { return typeOf obj === 'Object' &amp;&amp; obj !== null}function deepClone(obj) { if (!isObject(obj)) return obj let target = Array.isArray(obj) ? [] : {} for (let key in obj) { if (obj.hasOwnProperty(key)) { if (isObject(obj[key])) { target[key] = deepClone(obj[key]) } else { target[key] = obj[key] } } } return target} 相对复杂版123456789101112131415161718192021222324252627282930313233343536373839404142434445const getType = data =&gt; { // 获取数据类型 const baseType = Object.prototype.toString .call(data) .replace(/^\\[object\\s(.+)\\]$/g, \"$1\") .toLowerCase(); const type = data instanceof Element ? \"element\" : baseType; return type;};const isPrimitive = data =&gt; { // 判断是否是基本数据类型 const primitiveType = \"undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset\".split( \",\" ); // 其实还有很多类型 return primitiveType.includes(getType(data));};const isObject = data =&gt; getType(data) === \"object\";const isArray = data =&gt; getType(data) === \"array\";const deepClone = data =&gt; { let cache = {}; // 缓存值，防止循环引用 const baseClone = _data =&gt; { let res; if (isPrimitive(_data)) { return data; } else if (isObject(_data)) { res = { ..._data }; } else if (isArray(_data)) { res = [..._data]; } // 判断是否有复杂类型的数据，有就递归 Reflect.ownKeys(res).forEach(key =&gt; { if (res[key] &amp;&amp; getType(res[key]) === \"object\") { // 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题 if (cache[res[key]]) { res[key] = cache[res[key]]; } else { cache[res[key]] = res[key]; res[key] = baseClone(res[key]); } } }); return res; }; return baseClone(data);}; 实现图片懒加载1234567891011121314151617181920212223242526class lazyImage { constructor(el) { this.imageArr = Array.from(document.querySelectorAll(el)) // 取图片列表，即img标签列表 this.init() } bindEvent() { window.addEventListener('scroll',()=&gt;{ this.main() }) } main() { let h = window.innerHeight // 可视区域高度 for (let i = 0; i &lt; this.imageArr.length; i++) { if (this.imageArr[i].getBoundingClientRect().top &lt;= h) { let src = this.imageArr[i].getAttribute('date-src') this.imageArr[i].src = src this.imageArr.splice(i, 1) //已加载过的从图片数组里删除掉，避免后面onscroll不必要的循环 i-- } } }, init() { this.main() this.bindEvent() }} 函数防抖原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。debounce1234567891011121314function debounce(func, wait = 1000, immediate) { let timeout return function() { if (immediate) { func.apply(this, arguments) } if (timeout) { clearTimeout(timeout) } timeout = setTimeout(() =&gt; { func.apply(this, arguments) }, wait) }} 函数节流原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。1234567891011function throttle(func, wait) { let timeout return function() { if (!timeout) { timeout = setTimeout(() =&gt; { timeout = null func.apply(this, arguments) }, wait) } }} 并行处理多个异步函数12345678910111213141516async function asyncFunc() { const [result1, result2] = await Promise.all([ otherAsyncFunc1(), otherAsyncFunc2() ]) console.log(result1, result2)}// 等同于:function asyncFunc() { return Promise.all([ otherAsyncFunc1(), otherAsyncFunc2() ]).then([result1, result2] =&gt; { console.log(result1, result2) })} 用正则写一个根据name获取cookie中的值的方法123function getCookie(name) { } promise限制并发数123456789101112131415161718192021222324252627282930313233343536373839class LimitPromise { constructor (max) { this.max = max this.count = 0 this.taskQueue = [] } call(caller, ...args) { return new Promise((resolve, reject) =&gt; { const task = this.createTask(caller, args, resolve, reject) if (this.count &gt;= this.max) { this.taskQueue.push(task) } else { task() } }) } createTask(caller, args, resolve, reject) { return () =&gt; { // 实际上是在这里调用了异步任务，并将异步任务的返回（resolve和reject）抛给了上层 caller(...args) .then(resolve) .catch(reject) .finally(() =&gt; { // 任务队列的消费区，利用Promise的finally方法，在异步任务结束后，取出下一个任务执行 this.count -- if (this.taskQueue.length) { let task = this.taskQueue.shift() task() } }) this.count ++ } }}// 使用const limitP = new LimitPromise(10)limitP.call(request, url, params) 如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip123456789101112131415161718192021222324252627&lt;style&gt; div { width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;我是一段没有用的废话！&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let dDom = document.getElementsByTagName('div')[0]; let sDom = document.getElementsByTagName('span')[0]; let dDomWidth = sDom.parentNode.offsetWidth; let sDomWidth = sDom.offsetWidth; sDom.addEventListener('mouseover', function () { if (sDomWidth &gt; dDomWidth) { sDom.title = '我是一段没有用的废话！' } })&lt;/script&gt;","link":"/2018/08/21/frontInterview2/"},{"title":"前端面试题","text":"前端面试题目，持续更新 HTML你是如何理解 HTML 语义化的？ 最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签语义化的好处是已读、有利于SEO等。 知乎 - 初探 · HTML5语义化 说说盒模型 举例：标准盒模型(box-sizing: content-box)：width == 内容区宽度IE盒模型(box-sizing: border-box): width == 内容区宽度 + padding 宽度 + border 宽度高度以此类推。 js获取盒模型宽高假设已经获取的节点为 dom 1234567891011//只能获取内联样式设置的宽高dom.style.width/height//获取渲染后即时运行的宽高，值是准确的。但只支持 IEdom.currentStyle.width/height//获取渲染后即时运行的宽高，值是准确的。兼容性更好window.getComputedStyle(dom).width/height//获取渲染后即时运行的宽高，值是准确的。兼容性也很好，一般用来获取元素的绝对位置，getBoundingClientRect()会得到4个值：left, top, width, heightdom.getBoundingClientRect().width/height css reset 和 normalize.css 有什么区别？ reset 重置，之前的样式我不要，抛弃默认样式 normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一 如何居中？选择器优先级如何确定？ 选择器越具体，优先级越高。 #xxx 大于 .yyy 同样优先级，写在后面的覆盖前面的 color: red !important; 优先级最高 BFC 是什么？BFC : Block Formatting Context，块级格式化上下文，可以理解为是一种属性，这种属性影响着元素等定位以及其兄弟元素之间等相互作用。 BFC 区域不会与 float box 重叠 BFC 是页面上的一个独立容器，子元素不会影响到外面 计算 BFC 高度时，浮动元素也会参与计算生成条件: float 除 none 之外的值 position 为 fixed 和 absolute 的元素 display 为 inline-block 、 table-cell 、 table-caption 、 flex 、 inline-flex 的元素 overflow 不为 visible 的元素 (比如 : hidden 、 scroll 、 auto)例子:123456789&lt;div style=\"margin-bottom: 20px;\"&gt;&lt;/div&gt;&lt;div style=\"margin-top: 50px;\"&gt;&lt;/div&gt;&lt;!-- 上述代码他们的边距并不是 20 + 50 ，而是发生了重叠，取最大值50 --&gt;&lt;!-- 如何解决边距问题，创建BFC，给第二个div添加父元素，在父元素上生成BFC --&gt;&lt;div style=\"margin-bottom: 20px;\"&gt;&lt;/div&gt;&lt;div style=\"over-flow: hidden;\"&gt; &lt;div style=\"margin-top: 50px;\"&gt;&lt;/div&gt;&lt;/div&gt; 如何清除浮动？ overflow: hidden （不建议使用） .clearfix 清除浮动写在父级身上 12345678.clearfix::after{ content: ''; display: block; clear:both;}.clearfix{ zoom: 1; /* IE 兼容 */} JS 有哪些数据类型？ string number bool undefined null object symbol bigInt object 包括了数组、函数、正则、日期等对象 Promise 怎么使用？ then1$.ajax(...).then(成功函数, 失败函数) 链式 then1$.ajax(...).then(成功函数, 失败函数).then(成功函数2, 失败函数2) 如何自己生成 Promise 对象123456789101112function xxx(){ return new Promise(function(resolve, reject){ setTimeout(()=&gt;{ if(...){ resolve() //成功 }else{ reject() //失败 } },3000) })}xxx().then(...).catch(...) 手写原生AJAX12345678let xhr = XMLHttpRequest()xhr.open('POST','/url')xhr.send('a=1')xhr.onreadystatechange = function(){ if(xhr.readyState === 4 &amp;&amp; xhr.readyStatus === 200){ console.log(xhr.responseText) }} 闭包是什么？函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。12345678function func() { let a = 'something' function func1() { console.log(a) // 因为func1引用了它外层的变量a，因此func成为了闭包 } func1()}func()避免闭包导致内存泄漏的解决方法是，在相关函数执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。 闭包优点 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用 避免变量污染全局 把变量存到独立的作用域，作为私有成员存在 应用场景 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局 在循环中创建闭包，防止取到意外的值。如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 31234567891011121314for (var i = 0; i &lt; 3; i++) { document.getElementById('id' + i).onfocus = function() { alert(i); };}//可用闭包解决function makeCallback(num) { return function() { alert(num); };}for (var i = 0; i &lt; 3; i++) { document.getElementById('id' + i).onfocus = makeCallback(i);} 什么是内存泄漏？哪些情况会造成？js的内存泄漏场景、监控以及分析 这段代码里的 this 是什么？ fn() 里面的 this 就是 window fn() 是 strict mode(严格模式)，this 就是 undefined a.b.c.fn() 里面的 this 就是 a.b.c new F() 里面的 this 就是新生成的实例 () =&gt; console.log(this) 里面 this 跟外面的 this 的值一模一样，永远取它上级作用域的this 参考：知乎 - this 的值到底是什么？一次说清楚 什么是立即执行函数？使用立即执行函数的目的是什么？async/await 语法了解吗？目的是什么？如何实现数组去重？观察者模式 vs 发布-订阅模式观察者模式 vs 发布-订阅模式 JS继承JS继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//原型链继承Child.prototype = new Parent()//构造继承function Child() { Parent.call(this, ...arguments)}//组合继承function Child() { Parent.call(this, ...arguments)}Child.prototype = new Parent()Child.prototype.constructor = Child//寄生组合继承function Person(name) { this.name = name;}Person.prototype.sayName = function() { console.log(\"My name is \" + this.name + \".\");};function Student(name, grade) { Person.call(this, name); this.grade = grade;}Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.sayMyGrade = function() { console.log(\"My grade is \" + this.grade + \".\");};//原型式继承var child = Object.create(parent)//寄生式继承function createAnother(original) { var clone = Object.create(orginal) clone.fn = function() {} return clone}//混入方式继承function Child() { Parent.call(this) OtherParent.call(this)}Child.prototype = Object.create(Parent.prototype)Object.assign(Child.prototype, OtherParent.prototype)Child.prototype.constructor = Child CSRF XSSCSRFCSRF（Cross-site request forgery）跨站请求伪造。 攻击原理1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行 预防措施 验证 HTTP Referer 字段；Referer 来判断该请求是否为第三方网站发起的 在请求地址中添加 token 并验证；由服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效 在 HTTP 头中自定义属性并验证；可以对 Cookie 设置 SameSite 属性，该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击 XSSXSS（cross-site scripting）跨域脚本攻击 攻击原理存储型：1.攻击者将恶意代码提交到目标网站的数据库中2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等 反射型：1.攻击者构造出特殊的 URL，其中包含恶意代码2.用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等 DOM型：1.攻击者构造出特殊的 URL，其中包含恶意代码2.用户打开带有恶意代码的 URL3.用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞 预防措施 HTML：对以下敏感字符进行转义：&amp; &lt; &gt; ‘ “ / Javascript：把所有非字母、数字的字符都转义成小于256的ASCII字符 URL：使用Javascript的encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：, / ? : @ &amp; = + $ # 设置httpOnly 开启CSP，即开启白名单，可阻止白名单以外的资源加载和运行 请用一句话描述 try catch 能捕获到哪些 JS 异常能被 try catch 捕捉到的异常，必须是在报错的时候，线程执行已经进入 try catch 代码块，且处在 try catch 里面，这个时候才能被捕捉到try catch能捕获到哪些JS异常 DOM事件DOM事件的具体捕获流程捕获的流程为：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素冒泡的流程为：目标元素-&gt; … -&gt; body -&gt; html -&gt; document -&gt; window event对象常见使用1.event.preventDefault()取消事件的默认动作2.event.stopPropagation()阻止事件冒泡3.event.stopImmediatePropagation()阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他的两个事件将不会被执行 addEventListener的第三个参数true表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件 前端跨域前端跨域 页面性能优化1.资源压缩合并，减少 HTTP 请求2.非核心代码异步加载（异步加载的方式，异步加载的区别）3.利用浏览器缓存（缓存的分类，缓存原理）4.使用 CDN5.预解析 DNS 1234//强制打开 &lt;a&gt; 标签的 dns 解析&lt;meta http-equiv=\"x-dns-prefetch-controller\" content=\"on\"&gt;//DNS预解析&lt;link rel=\"dns-prefetch\" href=\"//host_name_to_prefetch.com\"&gt; 异步加载异步加载的方式：1.动态脚本加载 2.defer 3.async异步加载的区别：1.defer 浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。defer脚本会在 DOMContentLoaded 和 load 事件之前执行2.async 同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于script有先后依赖关系的情况，并不适用。async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序 浏览器缓存强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。no-store：非常粗暴，不进行任何形式的缓存。s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。 Expires和Cache-Control两者对比其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存失效，返回200和请求结果 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 Last-Modified和If-Modified-Since浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified 的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT；浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。 如果没有被修改：则开始`继续’传送文件，服务器返回: 200 OK 如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误) 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match ETag和If-None-MatchEtag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 Last-Modified和ETag两者对比 首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。 缓存场景对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 如何解决a标点击后hover事件失效只需要记住LoVe HAte原则就可以了1link→visited→hover→active CommonJS和ES6模块的区别 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 CommonJS 模块输出的是一个值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；ES6 模块输出的是值的引用，被输出模块的内部的改变会影响引用的改变 CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串 CommonJS this指向当前模块，ES6 Modules this指向undefined 且ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname 由于 ES Module 是在编译时就能确定模块之间的依赖关系，因此可以在编译的过程中进行代码优化，进行Tree Shaking去除无用代码； CommonJS 模块只有在运行时才能进行同步导入，因此无法在编译时确定是否拥有Dead Code从而进行剔除 (前端模块化：CommonJS,AMD,CMD,ES6)[https://juejin.im/post/5aaa37c8f265da23945f365c] HTTPSHTTP1.0和HTTP1.1的区别 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点 相对于HTTP1.1，HTTP2的优化： HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送 HTTP2支持多路复用（一次 TCP 连接可以处理多个请求） HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积 HTTP2支持服务端推送 HTTP2.0的多路复用和HTTP1.1中的长连接复用有什么区别 HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； 为什么HTTP1.1不能实现多路复用2.0是基于二进制帧的协议，1.1是基于文本分割解析的协议 HTTP3.0HTTP3.0是建立在UDP的基础上 连接迁移 由于QUIC基于UDP协议，所以一条UDP协议不再由四元组标识，而是以客户端随机产生的一个64位数字作为ID标识。只要ID不变，那么这条UDP就会存在，维持连接，上层业务逻辑就感受不到变化 无队头阻塞 http2.0的多路复用正好解决了http层的队头阻塞，但是tcp的队头阻塞依然存在。QUIC是基于udp的，创新点在于QUIC依靠一个严格的单调递增的packet序列，一个数据包里面还会有streamID和streamoffset偏移量，即使中途发生丢包或者超时确认，后面的数据包不会等待，等到接收完之后根据ID和offset即可完成重新拼装，从而避免了这种问题。 自定义的拥塞控制 前向安全和前向纠错 都说udp不太靠谱，但是Google给QUIC加上了这个机制：每发送一组数据之后，就对这组数据进行异或运算（效率高），并将结果也发送出去，那么接收方就有两份数据版本，可以对初始数据进行纠错和校验。以此保证了可靠性。 HTTP 与 HTTPS 的区别 HTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密 HTTP 的端口号是 80，HTTPS 是 443 HTTPS 需要到 CA 申请证书 HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全 HTTPS：HTTP + TLS（ 非对称加密 与 对称加密 ） 客户端发出 https 请求，请求服务端建立 SSL 连接 服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端 客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥 客户端将公钥与客户端私钥进行非对称加密后传给服务端 服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥 服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端 客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容 (HTTPS面试问答)[https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.md](一个故事讲完https)[https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA] TCP 和 UDPTCP/IP协议族按层次分别分为以下四层：应用层、传输层、网络层和数据链路层，TCP和UDP是指传输层两个性质不同的协议。 TCP传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。 基于流的方式 面向连接 丢包重传 保证数据顺序 确保数据能到达目标TCP是面向连接的，需要经历三次握手建立连接，四次握手断开连接，因此具有可靠性，且不会对报文进行操作，只是报文的搬运工。TCP仅支持单播传输，面向字节流，可以提供拥塞控制。 UDPInternet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。 UDP 是非连接的协议，也就是不会跟终端建立连接 UDP 包信息只有 8 个字节 UDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界 UDP 可能丢包 UDP 不保证数据顺序UDP是面向无连接的，不需要进行三次握手，不具有可靠性，具有单播、多播以及广播的功能。且是面向报文的，头部开销小，传输数据报文时很高效。 TCP 三次握手 四次挥手三次握手: 第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认 第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态 第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手 四次挥手: TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送，客户端进入FIN-WAIT-1 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号，服务端进入CLOSED-WAIT，客户端收到ACK后进入FIN-WAIT-2 服务器关闭客户端的连接，发送一个FIN给客户端，进入LAST-ACK阶段，收到客户端ACK报文后进入CLOSED 客户端发回ACK报文确认，并将确认序号设置为收到序号加1，客户端进入TIME-WAIT，等待2MSL后进入CLOSED 如何避免重排和重绘CSS： 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上 避免使用CSS表达式（例如：calc()） CSS3硬件加速（GPU加速） JavaScript： 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流 浏览器的Event LoopJavaScript的运行机制:1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。2.主线程之外，还存在”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。3.一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。4.主线程不断重复上面的第三步 概括即是: 调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作 JavaScript中有两种异步任务: 宏任务： script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering 微任务：process.nextTick（Nodejs） 、Promise 、Object.observe 、MutationObserver 事件循环(event-loop)是什么？ 主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行。 详细说明： 选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会跳转至microtask的执行步骤。 将事件循环的当前运行宏任务设置为已选择的宏任务。 运行宏任务。 将事件循环的当前运行任务设置为null。 将运行完的宏任务从宏任务队列中移除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。 Node的Event Loop timers: 执行setTimeout和setInterval中到期的callback。 pending callback: 上一轮循环中少数的callback会放在这一阶段执行。 idle, prepare: 仅在内部使用。 poll: 最重要的阶段，执行pending callback，在适当的情况下会阻塞在这个阶段。 check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。 close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。 每一轮事件循环都会经过六个阶段，在每个阶段后，都会执行microtask而nextTick并不在这些阶段中执行，它在每个阶段之后都会执行，并且优先级高于同一轮事件循环中其他microtask队列 说一说从输入URL到页面呈现发生了什么1.在浏览器地址栏内按下第一个键后浏览器会调用自己的算法，去书签栏或者历史记录中将我们可能访问的URL显示出来 2.点击要访问的URL后，浏览器会先检测URL是否合法，如果没问题会调用网络线程来准备发送网络请求 3.先在HTTP应用层内构建请求行，但不会发送网络请求，会先在强缓存中查找强缓存是否有效 4.强缓存无效的话，就会调用DNS域名解析将URL解析成IP地址 5.此时进入TCP传输层，进行TCP三次握手，握手完毕后将请求报文分割并打上标记生成数据包，将处理后的数据包转发给网络层 6.网络层拿到数据包后，调用ARP协议，通过IP地址反查出MAC地址 7.拿到IP地址、MAC地址、数据包后，在数据链路层内发起请求 8.服务端收到请求后，一层层的将报文剥开，其中就会把在传输层分割的报文组装起来，接着对请求会进行校验，比如是否有缓存字段、请求是否有权限。如果缓存有效，那么就会返回304状态码提醒浏览器使用缓存，这里其实就是协商缓存的步骤 9.如果缓存过期或者没设置，那么服务端就会返回请求的文件，如HTML、CSS和JS文件，浏览器接收到文件后，服务器会检测报文中的Connection的值是否等于keepw-alive，如果不是keep-alive就会断开链接，但在HTTP 1.1协议后，Connection默认为keep-alive 10.浏览器接收到HTML文件后就会进行处理，这个过程是交给渲染引擎的GUI线程来做，根据HTML文件中定义的charset和doctype来解析文档，GUI线程调用标记化算法和建树算法，实际上就是词法分析和语法分析，生成以document为根节点的DOM树 11.CSS的解析也是同理，只不过会先将CSS文件格式化成styleSheet对象，然后标准化这个对象，比如color: red这个属性会被格式化成16进制的数，最后将计算的结果挂载到window.getStyleComputed上，我们可以通过JS代码访问，但会引起回流 12.CSS解析和HTML解析互不干扰，但JS文件就会造成阻塞，因为渲染引擎中的JS线程和GUI线程是互斥的，且JS引擎的优先级比GUI线程高，会将GUI线程挂起，所以script会阻塞页面解析，要放在底部，而link CSS在头部 13.在拿到CSSOM树和DOM树后，会将二者合成为布局树，精确的计算出每一个节点所处的位置以及样式 14.浏览器在渲染前会进行图层处理，图层分为普通图层和复杂图层，而普通文档流内所有的元素所处的就是一个复杂图层，每个复杂图层都会被GPU单独绘制，所以它们之间的重绘不会影响其他图层，提成为复杂图层的方式有： 1.拥有层叠上下文的特点，如scroll 2.设置z-index 但要注意设置z-index的元素如果本身层叠上下文的等级就比较低，会引起层爆炸，在它上面的图层都会被提升成复杂图层，页面可能会崩溃 15.将绘制指令传入渲染队列中，通过合成线程生成图块和位图，开始渲染页面，所以常说要尽量使用opacity transform等属性，因为它们会调用GPU单独绘制，也就是所谓的硬件加速 进程和线程的区别进程：资源分配的最小单位 线程：资源调度的最小单位 首屏加载优化有哪些方案 Vue-Router路由懒加载（利用Webpack的代码切割） 使用CDN加速，将通用的库从vendor进行抽离 Nginx的gzip压缩 Vue异步组件 服务端渲染SSR 如果使用了一些UI库，采用按需加载 Webpack开启gzip压缩 如果首屏为登录页，可以做成多入口 Service Worker缓存文件处理 使用link标签的rel属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度） 谈谈你对作用域链的理解了解作用域链之前我们要知道一下几个概念： 函数的生命周期 变量和函数的声明 Activetion Object（AO）、Variable Object（VO） 函数的生命周期： 创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。 执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。 变量和函数的声明：如果变量名和函数名声明时相同，函数优先声明。 Activetion Object（AO）、Variable Object（VO）： AO：Activetion Object（活动对象） VO：Variable Object（变量对象） VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容： 变量 (var, 变量声明); 函数声明 (FunctionDeclaration, 缩写为FD); 函数的形参 AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了： 函数的所有局部变量 函数的所有命名参数 函数的参数集合 函数的this指向 作用域链： 当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 伪类和伪元素的区别伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。 flex容器的属性: flex-direction 属性决定主轴的方向（即项目的排列方向）。 flex-wrap 属性定义，如果一条轴线排不下，如何换行 flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content 属性定义了项目在主轴上的对齐方式。 align-items 属性定义项目在交叉轴上如何对齐 align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 项目的属性: order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 简单介绍一下 V8 引擎的垃圾回收机制v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。 新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。 新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步： （1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。 （2）如果对象不存活，则释放对象的空间。 （3）最后将 From 空间和 To 空间角色进行交换。 新生代对象晋升到老生代有两个条件： （1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。 （2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。 老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。 JS自定义事件12345678910//创建事件对象：let ev = document.createEvent('CustomEvent')//初始化事件对象：事件的类型名称/一个布尔值,表明该事件是否会冒泡/一个布尔值,表明该事件是否可以被取消/当事件初始化时传递的数据ev.initCustomEvent('ev', false, true, {b: 2})//监听事件：window.addEventListener('ev', e =&gt; { console.log(e) console.log(e.detail.b) // 2})window.dispatchEvent(ev) ES6 symbol理解及使用场景1: 使用Symbol来作为对象属性名(key)12345678910111213let obj = { [Symbol('name')]: 'pan', age: 27, title: 'Engineer'}Object.keys(obj) // ['age', 'title']for (let p in obj) { console.log(p) // 分别会输出：'age' 和 'title'}Object.getOwnPropertyNames(obj) // ['age', 'title']Symbol类型的key是不能通过Object.keys()或者for...in来枚举的，所以利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义 1JSON.stringify(obj) // {\"age\":27,\"title\":\"Engineer\"} 当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外,我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。 可以通过特定的Api获取Symbol定义的对象属性12345// 使用Object的APIObject.getOwnPropertySymbols(obj) // [Symbol(name)]// 使用新增的反射APIReflect.ownKeys(obj) // [Symbol(name), 'age', 'title'] 2: 使用Symbol来替代常量12345678const TYPE_AUDIO = 'AUDIO'const TYPE_VIDEO = 'VIDEO'const TYPE_IMAGE = 'IMAGE'// 有了Symbol，直接定义就保证了三个常量的值是唯一的const TYPE_AUDIO = Symbol()const TYPE_VIDEO = Symbol()const TYPE_IMAGE = Symbol() 3: 使用Symbol定义类的私有属性/方法 在a.js中 1234567891011121314const PASSWORD = Symbol()class Login { constructor(username, password) { this.username = username this[PASSWORD] = password } checkPassword(pwd) { return this[PASSWORD] === pwd }}export default Login 在b.js中 123456789import Login from './a'const login = new Login('admin', '123456')login.checkPassword('123456') // truelogin.PASSWORD // oh!no!login[PASSWORD] // oh!no!login[\"PASSWORD\"] // oh!no! 由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。 4: 注册和获取全局SymbolSymbol.for()它可以注册或获取一个window间全局的Symbol实例，这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。1234let gs1 = Symbol.for('global_symbol_1') //注册一个全局Symbollet gs2 = Symbol.for('global_symbol_1') //获取全局Symbolgs1 === gs2 // true ES6 Decorator理解及使用场景Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式。简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。ES6中Decorator功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法。12345678@testclass MyClass {}function test(target) { target.isTest = true}console.log(MyClass.isTest) // truebabel转换后的代码1234567var _classlet MyClass = test(_class = class MyClass {}) || _classfunction test(target) { target.isTest = true} 当然我们也通过修饰器，把某个对象的方法添加到目标类的实例上，注意要在类的prototype上添加。12345678910const foo = {isTestable: true}function testable(...list) { return target =&gt; {Object.assign(target.prototype, ...list)}}@testable(foo)class MyAnotherClass {}const obj = new MyAnotherClass()console.log('MyClass.isTestable', obj.isTestable) // true 多个修饰器的执行顺序是由外向内进入；再由内向外执行。123456789101112131415class Example { @decorator(1) @decorator(2) method(){}}function decorator(id) { console.log('id is ', id) return (target, property, descriptor) =&gt; console.log('executed', id)}// id is 1// id is 2// executed 2// executed 1 什么是沙箱？浏览器的沙箱有什么作用？操作系统层面的沙盒的含义就是操作系统对进程的可访问的内存地址所做的限制，限制进程可访问的内存在其被分配的内存地址区间内，而不允许操作其他的内存地址，从而提供安全层面的防护。到浏览器层面，本质原理没多大变化，实践层面可能会根据浏览器环境有所变化，比如限制脚本操作本页面之外的其他页面的DOM，限制访问非同源文档，限制向非同源服务器发送ajax等等，目的依然是安全。以chromium为例。chromium是多进程架构，浏览器前端界面由browser进程管理，各个web page的tab属于renderer进程管理。chromium的sandbox是将renderer进程作为防护对象。browser进程会给每个renderer进程分配资源，但这些renderer进程只能访问被分配的资源，不能访问未被分配的资源。这里资源的概念比较广泛，具体到可访问的DOM（对应内存中的对象），或抽象到origin scope等。 base64的优缺点优点 base64格式的图片是文本格式，占用内存小，转换后的大小比例大概为1/3，降低了资源服务器的消耗； 网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。 base64编码的字符串，更适合不同平台、不同语言的传输； 算法是编码, 不是压缩, 编码后只会增加字节数，但是算法简单, 几乎不会影响效率，算法可逆, 解码很方便, 不用于私密信息通信; 解码方便, 但毕竟编码了, 肉眼还是不能直接看出原始内容; 缺点 base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力； 网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。 base64无法缓存，要缓存只能缓存包含base64的文件，比如js或者css，这比直接缓存图片要差很多，而且一般HTML改动比较频繁，所以等同于得不到缓存效益。 参考：前端面试必备技巧前端面试与进阶指南","link":"/2018/10/21/frontInterview/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"JaveScript","slug":"JaveScript","link":"/tags/JaveScript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"原创文章","slug":"原创文章","link":"/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}