<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Panson的个人网站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://panpanson.github.io/"/>
  <updated>2020-07-16T02:30:22.061Z</updated>
  <id>https://panpanson.github.io/</id>
  
  <author>
    <name>Panson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note</title>
    <link href="https://panpanson.github.io/2020/07/08/note/"/>
    <id>https://panpanson.github.io/2020/07/08/note/</id>
    <published>2020-07-08T07:15:16.000Z</published>
    <updated>2020-07-16T02:30:22.061Z</updated>
    
    <content type="html"><![CDATA[<p>…</p><a id="more"></a><p>1.offsetleft offsettop<br>3.输入url到页面展示 发生了什么<br>4.返回字符串的最长不重复子串长度<br>5.flex 1 = flex grow 1  flex shrink 1  flex basic 0%<br>6.浏览器渲染也页面过程<br>7.手写 bind、reduce<br>8.webpack 的 require 是如何查找依赖的<br>9.webpack 如何实现动态加载<br>10.cookie新属性<br>11.dillPlugin<br>13.css3三角形<br>14.new function执行函数<br>15.项目中哪里使用了闭包，闭包如何引起内存泄漏<br>16.前端埋点，错误收集，页面白屏和加载时间收集<br>17.node转发实现</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://panpanson.github.io/2020/06/12/webpack/"/>
    <id>https://panpanson.github.io/2020/06/12/webpack/</id>
    <published>2020-06-12T05:46:09.000Z</published>
    <updated>2020-07-22T15:26:13.267Z</updated>
    
    <content type="html"><![CDATA[<p>webpack</p><a id="more"></a><h3 id="webpack如何打包优化"><a href="#webpack如何打包优化" class="headerlink" title="webpack如何打包优化"></a>webpack如何打包优化</h3><p>先使用webpack-bundle-analyzer分析打包后整个项目中的体积结构，既可以看到项目中用到的所有第三方包，又能看到各个模块在整个项目中的占比。</p><p>1.按需加载<br>1.1 路由按需加载<br>Vue中路由懒加载，使用<code>() =&gt; import(xxx.vue)</code>形式，打包会根据路由自动拆分打包。<br>1.2 第三方库按需加载<br>尽量按需加载，避免把整个库打包到项目中去。</p><p>2.文件解析优化<br>loader解析优化：通过配置<code>include</code>和<code>exclude</code>来减少被处理的文件，还可以配合<code>cacheDirectory</code>来缓存编译后的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader?cacheDirectory'</span>,</span><br><span class="line">      include: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">      ],</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文件解析优化：通过配置<code>resolve</code>选项中的<code>alias</code>、<code>extensions</code>、<code>modules</code>来实现。<br>alias：创建import或require的别名，加快webpack查找速度。<br>extensions：自动解析确定的扩展，尽可能减少后缀尝试的可能性，默认值为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [<span class="string">".js"</span>, <span class="string">".json"</span>]</span><br></pre></td></tr></table></figure><br>modules：解析模块时应该搜索的目录，通常建议使用绝对路径，避免层层查找祖先目录。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">"src"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  extensions: [<span class="string">".js"</span>, <span class="string">".vue"</span>],</span><br><span class="line">  mainFields: [<span class="string">"index"</span>, <span class="string">"main"</span>],</span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">"src"</span>),<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.拆分公共模块<br>使用splitChunks进行拆包，抽离公共模块。<br>splitChunks默认配置如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">  <span class="comment">// 表示选择哪些 chunks 进行分割，可选值有：async(按需加载)，initial(直接引用)和all</span></span><br><span class="line">  chunks: <span class="string">"async"</span>,</span><br><span class="line">  <span class="comment">// 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。</span></span><br><span class="line">  minSize: <span class="number">30000</span>,</span><br><span class="line">  <span class="comment">// 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。</span></span><br><span class="line">  minChunks: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 表示按需加载文件时，并行请求的最大数目。默认为5。</span></span><br><span class="line">  maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">  <span class="comment">// 表示加载入口文件时，并行请求的最大数目。默认为3。</span></span><br><span class="line">  maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js</span></span><br><span class="line">  automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">  <span class="comment">// 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。</span></span><br><span class="line">  name: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。</span></span><br><span class="line">  cacheGroups: &#123;</span><br><span class="line">    vendors: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">-10</span></span><br><span class="line">    &#125;,</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">      priority: <span class="number">-20</span>,</span><br><span class="line">      reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结下来就是：</p><ul><li>被复用代码或者来自<code>node_moules</code>文件夹中的模块</li><li>模块的体积大小必须大于等于30kb才进行拆分</li><li>当按需加载chunks时，并行请求的最大数量不能超过5</li><li>初始页面加载时，并行请求的最大数量不能超过3</li></ul><p>下面就是把node_modules中的react和moment再进行拆分，避免打包出的vendor包过大。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;  </span><br><span class="line">  chunks: <span class="string">'all'</span>,  </span><br><span class="line">  minSize: <span class="number">30000</span>,</span><br><span class="line">  minChunks: <span class="number">1</span>,</span><br><span class="line">  cacheGroups: &#123;    </span><br><span class="line">    lib: &#123;      </span><br><span class="line">      name: <span class="string">'vendors'</span>,      </span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,      </span><br><span class="line">      priority: <span class="number">10</span>,      </span><br><span class="line">      chunks: <span class="string">'initial'</span> <span class="comment">// 只打包初始时依赖的第三方    </span></span><br><span class="line">    &#125;,    </span><br><span class="line">    react: &#123;      </span><br><span class="line">      name: <span class="string">'react'</span>, <span class="comment">// 单独将 react 拆包      </span></span><br><span class="line">      priority: <span class="number">20</span>,</span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]react[\\/]/</span>,      </span><br><span class="line">      chunks: <span class="string">'all'</span>    </span><br><span class="line">    &#125;,</span><br><span class="line">    moment: &#123;</span><br><span class="line">      name: <span class="string">'moment'</span>, <span class="comment">//单独将moment拆包</span></span><br><span class="line">      priority: <span class="number">20</span>,</span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]moment[\\/]/</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">      priority: <span class="number">-20</span>,</span><br><span class="line">      reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.DllPlugin和DllReferencePlugin<br>通常打包过程中，由于第三方库代码不经常改变，我们可以将第三方库的代码跟业务代码抽离，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。<br>DllPlugin 和 DLLReferencePlugin 可以实现拆分 bundles，并且可以大大提升构建速度，DllPlugin 和 DLLReferencePlugin 都是 webpack 的内置模块。</p><p>配置webpack.dll.js，将lodash、jquery、antd抽离出来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    lodash: [<span class="string">"lodash"</span>],</span><br><span class="line">    jquery: [<span class="string">"jquery"</span>],</span><br><span class="line">    antd: [<span class="string">"antd"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].dll.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dll"</span>),</span><br><span class="line">    library: <span class="string">"[name]"</span> <span class="comment">// name和library保持一致</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">"[name]"</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"manifest/[name].manifest.json"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>配置package.json中，新增script打包dll<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  ...,</span><br><span class="line">  &quot;dll&quot;: &quot;webpack --config webpack.dll.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行npm run dll，生成dll文件和对应的manifest.json。</p><p>将打包的dll通过add-asset-html-webpack-plugin添加到html中，再通过DllReferencePlugin把dll引用到需要编译的依赖。</p><p>配置<code>webpack.config.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> manifests = [<span class="string">'antd'</span>, <span class="string">'jquery'</span>, <span class="string">'lodash'</span>];</span><br><span class="line"><span class="keyword">const</span> dllPlugins = manifests.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: <span class="built_in">require</span>(<span class="string">`./manifest/<span class="subst">$&#123;item&#125;</span>.manifest`</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...dllPlugins,</span><br><span class="line">    <span class="keyword">new</span> AddAssetHtmlPlugin(&#123;</span><br><span class="line">      filepath: path.resolve(__dirname, <span class="string">"./dll/*.dll.js"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.开启多线程压缩<br>使用 terser-webpack-plugin 开启多线程压缩<br>PS：构建时可以使用 thread-loader，会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserPlugin(</span><br><span class="line">      parallel: <span class="literal">true</span>   <span class="comment">// 多线程</span></span><br><span class="line">    )],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>6.speed-measure-webpack-plugin<br>简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</p><h3 id="hash-chunkhash-contenthash-区别"><a href="#hash-chunkhash-contenthash-区别" class="headerlink" title="hash chunkhash contenthash 区别"></a>hash chunkhash contenthash 区别</h3><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>hash是跟整个项目的构建相关，构建生成的文件hash值都是一样的，所以hash计算是跟整个项目的构建相关，同一次构建过程中生成的hash都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。<br>如果出口是hash，那么一旦针对项目中任何一个文件的修改，都会构建整个项目，重新获取hash值，缓存的目的将失效。</p><h4 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h4><p>chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成hash值，那么只要我们不改动公共库的代码，就可以保证其hash值不会受影响。<br>由于采用chunkhash，所以项目主入口文件main.js及其对应的依赖文件main.css由于被打包在同一个模块，所以共用相同的chunkhash，但是公共库由于是不同的模块，所以有单独的chunkhash。这样子就保证了在线上构建时只要文件内容没有更改就不会重复构建。</p><h4 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h4><p>contenthash表示由文件内容产生的hash值，内容不同产生的contenthash值也不一样。在项目中，通常做法是把项目中css都抽离出对应的css文件来加以引用。</p><p>(webpack相关优化)[<a href="https://github.com/lgwebdream/FE-Interview/issues/25]">https://github.com/lgwebdream/FE-Interview/issues/25]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="https://panpanson.github.io/2020/06/12/vue3/"/>
    <id>https://panpanson.github.io/2020/06/12/vue3/</id>
    <published>2020-06-12T03:34:36.000Z</published>
    <updated>2020-07-12T13:58:18.897Z</updated>
    
    <content type="html"><![CDATA[<p>Vue3</p><a id="more"></a><h3 id="compositon-api"><a href="#compositon-api" class="headerlink" title="compositon api"></a>compositon api</h3><ul><li><p>与 2.x 版本生命周期相对应的组合式 API<br>beforeCreate -&gt; 使用 setup()<br>created -&gt; 使用 setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>errorCaptured -&gt; onErrorCaptured</p></li><li><p>新增的钩子函数<br>onRenderTracked<br>onRenderTriggered</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue3&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://panpanson.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue" scheme="https://panpanson.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://panpanson.github.io/2020/05/12/designPatterns/"/>
    <id>https://panpanson.github.io/2020/05/12/designPatterns/</id>
    <published>2020-05-12T10:54:14.000Z</published>
    <updated>2020-07-16T02:30:22.060Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式：单例模式、策略模式、装饰者模式、发布订阅模式、代理模式（待补充）</p><a id="more"></a><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式两个条件</p><ul><li>确保只有一个实例</li><li>可以全局访问</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">singleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123; <span class="comment">// 关键点</span></span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> singleton(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>根据不同参数可以命中不同的策略，优点有</p><ul><li>能减少大量的 if 语句</li><li>复用性好</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> S = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> A = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> B = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">func, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func(salary)</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(A, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><ul><li>为对象添加新功能</li><li>不改变其原有的结构和功能<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.wirteable = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = <span class="string">'tony'</span>;</span><br><span class="line">    <span class="keyword">this</span>.secondName = <span class="string">'parker'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.secondName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(a.name());</span><br><span class="line">a.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;; <span class="comment">// 修改name，报错</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理对象和本体对象具有一致的接口, 对使用者友好</p><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  list: &#123;&#125;,</span><br><span class="line">  on(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  emit() &#123;</span><br><span class="line">    <span class="keyword">let</span> key = [].shift.call(<span class="built_in">arguments</span>), fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  remove(key, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">if</span> (!fns) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fns.forEach(<span class="function">(<span class="params">cb, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn === cb) &#123;</span><br><span class="line">          fns.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布订阅者模式和观察者模式的区别？"><a href="#发布订阅者模式和观察者模式的区别？" class="headerlink" title="发布订阅者模式和观察者模式的区别？"></a>发布订阅者模式和观察者模式的区别？</h3><p>发布/订阅模式是观察者模式的一种变形，两者区别在于，<strong>发布/订阅模式在观察者模式的基础上，在目标和观察者之间增加一个调度中心。</strong><br>单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向。该模式存在不稳定性，发布者无法感知订阅者的状态。</p><p>观察者模式是由具体目标调度，比如当事件触发，Subject 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。<br>目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的。</p><p>发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式：单例模式、策略模式、装饰者模式、发布订阅模式、代理模式（待补充）&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://panpanson.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://panpanson.github.io/2020/04/26/vue/"/>
    <id>https://panpanson.github.io/2020/04/26/vue/</id>
    <published>2020-04-26T06:47:51.000Z</published>
    <updated>2020-07-12T14:49:34.451Z</updated>
    
    <content type="html"><![CDATA[<p>Vue</p><a id="more"></a><h3 id="Vue的优点及缺点"><a href="#Vue的优点及缺点" class="headerlink" title="Vue的优点及缺点"></a>Vue的优点及缺点</h3><p><strong>响应式</strong>：这也就是vue.js最大的优点，通过MVVM思想实现数据的双向绑定，通过虚拟DOM让我们可以用数据来操作DOM，而不必去操作真实的DOM，提升了性能。且让开发者有更多的时间去思考业务逻辑。</p><p><strong>组件化</strong>：把一个单页应用中的各个模块拆分到一个个组件当中，或者把一些公共的部分抽离出来做成一个可复用的组件。所以组件化带来的好处就是，提高了开发效率，方便重复使用，使项目的可维护性更强。</p><p><strong>缺点</strong>：</p><ul><li>不利于seo。</li><li>导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。</li><li>初次加载时耗时多。</li></ul><h3 id="Vue-Router完整的导航解析流程"><a href="#Vue-Router完整的导航解析流程" class="headerlink" title="Vue Router完整的导航解析流程"></a>Vue Router完整的导航解析流程</h3><ul><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ul><h3 id="对MVVM的理解"><a href="#对MVVM的理解" class="headerlink" title="对MVVM的理解"></a>对MVVM的理解</h3><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。<br>Model 层: 对应数据层的域模型，它主要做域模型的同步。<br>View 层: 作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。<br>ViewModel 层: 把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。</p><h4 id="MVVM优点"><a href="#MVVM优点" class="headerlink" title="MVVM优点"></a>MVVM优点</h4><p>1.分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑<br>2.提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码<br>3.自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放</p><h4 id="MVVM缺点"><a href="#MVVM缺点" class="headerlink" title="MVVM缺点"></a>MVVM缺点</h4><p>1.Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的<br>2.一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex的流向：</p><p>view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）<br>view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p><p>state 定义了应用状态的数据结构，可以在这里设置默认的初始状态<br>mutations 同步操作，更改store状态,通过commit显示触发<br>actions 用于提交 mutation，而不是直接变更状态，可以包含任意异步操作，通过dispatch分发<br>Module 允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中<br>Getter store的计算属性，返回值会根据它的依赖被缓存起来，处理一些比较复杂的函数</p><h3 id="Vue初始化流程"><a href="#Vue初始化流程" class="headerlink" title="Vue初始化流程"></a>Vue初始化流程</h3><ul><li>创建Vue实例对象</li><li>init过程会初始化生命周期，初始化事件中心，初始化渲染、执行beforeCreate周期函数、初始化 data、props、computed、watcher、执行created周期函数等。</li><li>初始化后，调用$mount方法对Vue实例进行挂载（挂载的核心过程包括模板编译、渲染以及更新三个过程）。</li><li>如果没有在Vue实例上定义render方法而是定义了template，那么需要经历编译阶段。需要先将template 字符串编译成 render function，template 字符串编译步骤如下 ：<ul><li>parse正则解析template字符串形成AST（抽象语法树，是源代码的抽象语法结构的树状表现形式）</li><li>optimize标记静态节点跳过diff算法（diff算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有O(n)。如果对于时间复杂度不是很清晰的）</li><li>generate将AST转化成render function字符串</li></ul></li><li>编译成render function 后，调用$mount的mountComponent方法，先执行beforeMount钩子函数，然后核心是实例化一个渲染Watcher，在它的回调函数（初始化的时候执行，以及组件实例中监测到数据发生变化时执行）中调用updateComponent方法（此方法调用render方法生成虚拟Node，最终调用update方法更新DOM）。</li><li>调用render方法将render function渲染成虚拟的Node（真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。如果频繁的去做 DOM 更新，会产生一定的性能问题，而 Virtual DOM 就是用一个原生的 JavaScript 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多，而且修改属性也很轻松，还可以做到跨平台兼容），render方法的第一个参数是createElement(或者说是h函数)，这个在官方文档也有说明。</li><li>生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用pacth方法把虚拟DOM转换成真正的DOM节点。需要注意在图中忽略了新建真实DOM的情况（如果没有旧的虚拟Node，那么可以直接通过createElm创建真实DOM节点），这里重点分析在已有虚拟Node的情况下，会通过sameVnode判断当前需要更新的Node节点是否和旧的Node节点相同（例如我们设置的key属性发生了变化，那么节点显然不同），如果节点不同那么将旧节点采用新节点替换即可，如果相同且存在子节点，需要调用patchVNode方法执行diff算法更新DOM，从而提升DOM操作的性能。</li></ul><h3 id="Vue双向绑定原理"><a href="#Vue双向绑定原理" class="headerlink" title="Vue双向绑定原理"></a>Vue双向绑定原理</h3><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><ul><li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li><li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。<br><img src="/images/171fec54e0e57df5.webp"></li></ul><h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><ul><li>在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。</li><li>当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。</li></ul><h3 id="Vue的数据为什么频繁变化但只会更新一次"><a href="#Vue的数据为什么频繁变化但只会更新一次" class="headerlink" title="Vue的数据为什么频繁变化但只会更新一次"></a>Vue的数据为什么频繁变化但只会更新一次</h3><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MessageChannel</code>，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。<br>另外，关于<code>waiting</code>变量，这是很重要的一个标志位，它保证<code>flushSchedulerQueue</code>回调（$nextTick中执行）允许被置入<code>callbacks</code>一次。<br>因为Vue的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：<br>现在有这样的一种情况，mounted的时候test的值会被循环执行++1000次。 每次++时，都会根据响应式触发<code>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</code>。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个queue队列，在下一个tick（或者是当前tick的微任务阶段）统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick（或者是当前tick的微任务阶段）的时候调用，大大优化了性能。<br>执行顺序<code>update -&gt; queueWatcher -&gt; 维护观察者队列（重复id的Watcher处理） -&gt; waiting标志位处理（保证需要更新DOM或者Watcher视图更新的方法flushSchedulerQueue只会被推入异步执行的$nextTick回调数组一次） -&gt; 处理$nextTick（在为微任务或者宏任务中异步更新DOM）-&gt;</code></p><ul><li>Vue是异步更新Dom的，Dom的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行</li></ul><p>由于VUE的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM完成更新，立即执行nextTick(callback)内的回调。</p><h3 id="虚拟-Dom-实现原理"><a href="#虚拟-Dom-实现原理" class="headerlink" title="虚拟 Dom 实现原理"></a>虚拟 Dom 实现原理</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul><p><strong>优点：</strong></p><ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p><strong>缺点:</strong></p><ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul><p>(Vue核心之虚拟DOM)[<a href="https://juejin.im/post/5d36cc575188257aea108a74]">https://juejin.im/post/5d36cc575188257aea108a74]</a></p><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p><strong>全局前置守卫</strong><br>注意一定要调用 <code>next()</code>; ，否则钩子就不会被 resolved。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>全局解析守卫</strong><br>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p><p><strong>全局后置钩子</strong><br>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>路由独享的守卫</strong><br>你可以在路由配置上直接定义 beforeEnter 守卫：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>组件内的守卫</strong><br>最后，你可以在路由组件内直接定义以下路由导航守卫：</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate (2.2 新增)</li><li>beforeRouteLeave<br>注意要调用 next()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><ul><li><p>加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li><li><p>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li><li><p>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</p></li><li><p>销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul><h3 id="hash-history-两种模式有什么区别"><a href="#hash-history-两种模式有什么区别" class="headerlink" title="hash / history 两种模式有什么区别"></a>hash / history 两种模式有什么区别</h3><p>Vue底层对它们的实现方式不同</p><p>hash模式是依靠onhashchange事件(监听location.hash的改变)</p><p>history模式是主要是依靠的HTML5 history中新增的两个方法(监听window.onpopstate)</p><ul><li>pushState()可以改变url地址且不会发送请求</li><li>replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改</li></ul><p>当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持</p><p>因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如<a href="http://www.xxx.com/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面">www.xxx.com/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面</a></p><p>(30 道 Vue 面试题)[<a href="https://juejin.im/post/5d59f2a451882549be53b170]">https://juejin.im/post/5d59f2a451882549be53b170]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://panpanson.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue" scheme="https://panpanson.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://panpanson.github.io/2020/04/26/nginx/"/>
    <id>https://panpanson.github.io/2020/04/26/nginx/</id>
    <published>2020-04-26T06:47:51.000Z</published>
    <updated>2020-07-12T14:01:35.434Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx</p><a id="more"></a><h3 id="nginx正向代理、反向代理、负载均衡相关"><a href="#nginx正向代理、反向代理、负载均衡相关" class="headerlink" title="nginx正向代理、反向代理、负载均衡相关"></a>nginx正向代理、反向代理、负载均衡相关</h3><p>1.正向代理<br>正向代理是为客户端服务的，通过代理客户端的请求，去访问客户端本身无法直接访问的服务器，翻墙工具就是最常见的正向代理。正向代理对于客户端透明，对于服务器端不透明。<br>nginx配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  resolver 8.8.8.8;       #指定DNS服务器IP地址 </span><br><span class="line">  listen 80;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;$host;     #设定代理服务器的协议和地址 </span><br><span class="line">    proxy_set_header HOST $host;</span><br><span class="line">    proxy_buffers 256 4k;</span><br><span class="line">    proxy_max_temp_file_size 0k;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.反向代理<br>反向代理是指为服务端服务的，反向代理接收来自客户端的请求，帮助服务器进行请求转发、负载均衡等。通常解决前端跨域问题也是通过反向代理实现的。反向代理对于服务端是透明的，对于客户端是不透明的。<br>nginx配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name  xx.a.com; &#x2F;&#x2F; 监听地址</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    root html;</span><br><span class="line">    proxy_pass xx.b.com; &#x2F;&#x2F; 请求转向地址</span><br><span class="line">    index index.html; &#x2F;&#x2F; 设置默认页</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.负载均衡<br>负载均衡是指nginx将大量客户端的请求合理地分配到各个服务器上，以达到服务端资源的充分利用和更快的响应请求。<br>nginx配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  server_name  xx.a.com;</span><br><span class="line">  listen 80;</span><br><span class="line">  location &#x2F;api &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;balanceServer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>常用的负载均衡策略：</p><ul><li>轮询策略: 默认策略，遍历服务器节点列表，逐一分配请求，如果服务器down掉，自动剔除。</li><li>加权轮询: 每台服务器有不同的权重，一般权重越大意味着该服务器的性能越好，可以承载更多的请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  server 1.1.2.3:80 weight&#x3D;5;</span><br><span class="line">  server 1.1.2.4:80 weight&#x3D;10;</span><br><span class="line">  server 1.1.2.5:80 weight&#x3D;20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最小连接策略: 将请求优先分配给压力较小的服务器，避免压力大的服务器添加更多的请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  least_conn;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最快响应时间策略: 将请求有限分配给响应时间最短的服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  fair;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>客户端ip绑定: 将来自同一个ip的请求永远只分配给一台固定的服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考：<br><a href="https://juejin.im/post/5d01bcc7f265da1b91638d75">前端开发者必备的 Nginx 知识</a><br><a href="https://juejin.im/post/5ea931866fb9a043815146fb">nginx万字详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://panpanson.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nginx" scheme="https://panpanson.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://panpanson.github.io/2020/04/16/promise/"/>
    <id>https://panpanson.github.io/2020/04/16/promise/</id>
    <published>2020-04-16T08:08:35.000Z</published>
    <updated>2020-07-16T02:30:22.062Z</updated>
    
    <content type="html"><![CDATA[<p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态，而不管其是否处理成功。</p><p>依照PromiseA+规范 的Promise<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise, x, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise) &#123;</span><br><span class="line">    <span class="comment">// If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if x is an object or function,</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span></span><br><span class="line">    <span class="keyword">let</span> called</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then <span class="comment">// Let then be x.then</span></span><br><span class="line">      <span class="comment">// If then is a function, call it with x as this</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span></span><br><span class="line">        <span class="comment">// If/when rejectPromise is called with a reason r, reject promise with r.</span></span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          resolvePromise(promise, y, resolve, reject)</span><br><span class="line">        &#125;, r =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If then is not a function, fulfill promise with x.</span></span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If x is not an object or function, fulfill promise with x</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 存放成功/失败的队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks = []</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果value是一个Promise 递归解析</span></span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = FULFILLED</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED</span><br><span class="line">        <span class="keyword">this</span>.reason = reason</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject) <span class="comment">// 立即执行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 判断 onFulfilled, onRejected 是否是函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line">    <span class="keyword">let</span> newPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            resolvePromise(newPromise, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            resolvePromise(newPromise, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">              resolvePromise(newPromise, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">              resolvePromise(newPromise, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newPromise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Promise.catch</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description  </span>用于promise方法链示，捕获前面 onFulfilled/onRejected 抛出的异常</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>errorCallback </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">catch</span>(errorCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, errorCallback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Promise.finally</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>finally 传入的函数 无论成功和失败都执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>返回成功/失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回上一次的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value)</span><br><span class="line">    &#125;, error =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Promise.all</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve 当有一个promise对象变为reject状态时 直接 reject</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>values promise对象组成的数组作为参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>返回一个promise实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> all(values) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> resultArr = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">const</span> resultArrByKey = <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;</span><br><span class="line">        resultArr[index] = value</span><br><span class="line">        <span class="keyword">if</span> (++count === values.length) &#123;</span><br><span class="line">          resolve(resultArr)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      values.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          resultArrByKey(index, value)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Promise.race</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>只要有一个promise对象进入FULFILLED 或者  REJECTED 状态的话，就会继续执行后面的处理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>values  接受promise对象组成的数组作为参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>返回一个Promise实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> race(values) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      values.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.then(resolve, reject)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认产生一个成功的promise</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认产生一个失败的promise</span></span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> defer = &#123;&#125;</span><br><span class="line">  defer.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    defer.resolve = resolve</span><br><span class="line">    defer.reject = reject</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> defer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Promise.allSettled&lt;/code&gt;跟&lt;code&gt;Promise.all&lt;/code&gt;类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用工具类函数</title>
    <link href="https://panpanson.github.io/2020/04/09/utils/"/>
    <id>https://panpanson.github.io/2020/04/09/utils/</id>
    <published>2020-04-09T05:32:45.000Z</published>
    <updated>2020-04-25T06:12:17.021Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JaveScript" scheme="https://panpanson.github.io/tags/JaveScript/"/>
    
  </entry>
  
  <entry>
    <title>基础算法</title>
    <link href="https://panpanson.github.io/2019/06/10/algorithm/"/>
    <id>https://panpanson.github.io/2019/06/10/algorithm/</id>
    <published>2019-06-10T02:50:04.000Z</published>
    <updated>2020-07-12T13:57:56.587Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法及算法题目整合</p><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> isSort = <span class="literal">false</span> <span class="comment">// 优化冒泡排序，表示此次循环没有进行交换，即待排序列已经有序，排序已然完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        isSort = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isSort) <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &gt; arr[j]) &#123; <span class="comment">// 寻找最小值</span></span><br><span class="line">        index = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[index]</span><br><span class="line">      arr[index] = arr[i]</span><br><span class="line">      arr[i] = temp  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> temp,j</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp) &#123;</span><br><span class="line">      arr[j] = arr[j<span class="number">-1</span>]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr === <span class="literal">null</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) <span class="comment">// 获取基准值的index</span></span><br><span class="line">  <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>) <span class="comment">// 获取对应基准值</span></span><br><span class="line">  <span class="keyword">let</span> left = [], right = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...quickSort(left), pivot, ...quickSort(right)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化快速排序（原地排序）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort2</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = left - <span class="number">1</span> <span class="comment">// 定义一个pos指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> pivot = arr[right]</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">        pos++</span><br><span class="line">        <span class="keyword">let</span> swapItem = arr[pos]</span><br><span class="line">        arr[pos] = arr[i]</span><br><span class="line">        arr[i] = swapItem</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一趟排序完成后，pos位置即基准数的位置，以pos的位置左右分割数组</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>)</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还可以再优化<br>1：当是有序数组时，取基准点时也顺序取，就可能导致基准点一侧的子数组一直为空<br>2：数组中重复的数据比较多<code>[1,2,2,2,2,2,2,7]</code>，无论基准点取哪个值，都会导致基准点两侧数组大小不平衡, 影响快排效率</p><p>对于第一个问题, 我们可以通过在取基准点的时候随机化来解决，对于第二个问题，我们可以使用三路快排的方式来优化</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">const</span> midIndex = arr.length / <span class="number">2</span> | <span class="number">0</span> <span class="comment">// 向下取整</span></span><br><span class="line">  <span class="keyword">const</span> leftArr = arr.slice(<span class="number">0</span>, midIndex)</span><br><span class="line">  <span class="keyword">const</span> rightArr = arr.slice(midIndex, arr.length)</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(leftArr), mergeSort(rightArr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">leftArr, rightArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (leftArr.length &amp;&amp; rightArr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArr[<span class="number">0</span>] &lt;= rightArr[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(leftArr.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(rightArr.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(leftArr.length) result.push(leftArr.shift())</span><br><span class="line">  <span class="keyword">while</span>(rightArr.length) result.push(rightArr.shift())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> temp = arr[index]</span><br><span class="line">    arr[index] = arr[i]</span><br><span class="line">    arr[i] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通递归版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">".."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> fib1(n - <span class="number">1</span>) + fib1(n - <span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 尾调用 优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib2</span>(<span class="params">n, a = <span class="number">0</span>, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">".."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib2(n - <span class="number">1</span>, b , a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 备忘录递归法</span></span><br><span class="line"><span class="keyword">const</span> hashMap = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">".."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">if</span> (hashMap[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashMap[n];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> value = fib3(n - <span class="number">1</span>) + fib3(n - <span class="number">2</span>);</span><br><span class="line">  hashMap[n] = value;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib4</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">".."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    [a, b] = [b, a+b];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LRU算法-Least-Recently-Used-：最近最少使用"><a href="#LRU算法-Least-Recently-Used-：最近最少使用" class="headerlink" title="LRU算法(Least Recently Used ：最近最少使用)"></a>LRU算法(Least Recently Used ：最近最少使用)</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法及算法题目整合&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://panpanson.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Node</title>
    <link href="https://panpanson.github.io/2019/06/09/node/"/>
    <id>https://panpanson.github.io/2019/06/09/node/</id>
    <published>2019-06-09T09:19:58.000Z</published>
    <updated>2020-07-12T14:01:58.674Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js相关</p><a id="more"></a><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>基础概念：</p><ul><li>进程：进程（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。</li><li>线程：线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</li><li>协程：协程（英语：coroutine），又称微线程，是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。<br>Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的，各个线程如下：</li><li>主线程：编译、执行代码。</li><li>编译/优化线程：在主线程执行的时候，可以优化代码。</li><li>分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。</li><li>垃圾回收的几个线程。</li></ul><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p>注意：每个框被称为事件循环机制的一个阶段。</p><p>阶段概述：</p><ul><li>定时器 ：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</li><li>待定回调 ：执行延迟到下一个循环迭代的 I/O 回调。</li><li>idle, prepare ：仅系统内部使用。</li><li>轮询 ：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li>检测 ：setImmediate() 回调函数在这里执行。</li><li>关闭的回调函数 ：一些关闭的回调函数，如：socket.on(‘close’, …)。</li></ul><p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js相关&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo + Icarus + Github 搭建个人站点</title>
    <link href="https://panpanson.github.io/2019/01/16/hexoBlog/"/>
    <id>https://panpanson.github.io/2019/01/16/hexoBlog/</id>
    <published>2019-01-16T10:25:19.000Z</published>
    <updated>2021-08-17T04:06:00.134Z</updated>
    
    <content type="html"><![CDATA[<p>本文将基于Hexo构建博客网站，替换theme主题为Icarus，最后通过Github部署发布，这样可以通过Github分发的网站链接进行访问，<br>当然也可以自己购买域名和服务器进行部署，但此文暂时不涉及这部分内容<br><a id="more"></a></p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><p>下载 <a href="https://nodejs.org/en/">Node.js</a>，按照步骤安装即可。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>下载 <a href="https://git-scm.com/downloads">Git</a>，同样按照步骤安装即可。</p><h3 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h3><blockquote><p>如果部署在自己的服务器可以忽略这步，并不影响Hexo的使用</p></blockquote><p>注册 <a href="https://github.com/">GitHub</a>，已有的默认请忽略</p><h2 id="2-安装使用Hexo"><a href="#2-安装使用Hexo" class="headerlink" title="2.安装使用Hexo"></a>2.安装使用Hexo</h2><h3 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h3><p>Node 和 Git 都安装好后，可执行以下命令安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><br>然后执行初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;文件名&gt;</span><br></pre></td></tr></table></figure><br>或者可以cd到指定目录下，直接执行 hexo init</p><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy      &#x2F;&#x2F;执行hexo deploy命令部署到GitHub上的内容目录</span><br><span class="line">├── public       &#x2F;&#x2F;执行hexo generate命令，输出的静态网页内容目录</span><br><span class="line">├── scaffolds    &#x2F;&#x2F;layout模板文件目录，其中的md文件可以添加编辑</span><br><span class="line">├── scripts      &#x2F;&#x2F;扩展脚本目录，这里可以自定义一些javascript脚本</span><br><span class="line">├── source       &#x2F;&#x2F;文章源码目录，该目录下可新建页面目录</span><br><span class="line">|   ├── _drafts  &#x2F;&#x2F;草稿文章</span><br><span class="line">|   └── _posts   &#x2F;&#x2F;发布文章</span><br><span class="line">├── themes       &#x2F;&#x2F;主题文件目录</span><br><span class="line">├── _config.yml  &#x2F;&#x2F;全局配置文件</span><br><span class="line">└── package.json &#x2F;&#x2F;应用程序数据，指明hexo的版本等信息</span><br></pre></td></tr></table></figure><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><p>安装并执行完初始化后，可以执行以下命令，启动本地服务，预览界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><br>浏览器输入 <a href="http://localhost:4000">http://localhost:4000</a> 就可以看到效果了</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>执行以下new命令，会自动生成指定名称的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;文章名&gt;</span><br></pre></td></tr></table></figure><br>我们可以看一下生成的文件  文件名\source\ _posts\文章名.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 文章名 #文章页面上的显示名称，可以任意修改，不会出现在URL中</span><br><span class="line">date: 2018-12-22 18:33:58 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: #文章分类目录，可以为空，注意:后面有个空格</span><br><span class="line">tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格</span><br><span class="line">---</span><br><span class="line">这里开始使用markdown格式输入你的正文</span><br></pre></td></tr></table></figure><br>如果你想使用文章的摘要功能，只需要添加<!--more-->即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: 文章名 </span><br><span class="line">date: 2018-12-22 18:33:58 </span><br><span class="line">categories: Hexo</span><br><span class="line">tags: tag1</span><br><span class="line">---</span><br><span class="line">我是摘要，在主页显示</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">下面是文章余下的内容，不在主页显示</span><br></pre></td></tr></table></figure><br>more以上内容即是文章摘要，在主页显示，more以下内容点击Read More链接打开全文才显示。</p><blockquote><p>在文件名\source\ _posts\下手动生成一个.md文件也是可以的</p></blockquote><hr><p>关于写作的模板用法或其他相关可以参考 <a href="https://hexo.io/zh-cn/docs/writing">Hexo文档</a> 本文只记录主要步骤</p><h2 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3.更换主题"></a>3.更换主题</h2><p>Hexo的社区提供了200多个主题，你可以挑选自己喜欢的clone下来使用，<a href="https://hexo.io/themes/">Hexo主题</a></p><p>推荐两款，Next是比较受追捧的一款，Apollo我个人认为是一款简洁易扩展定制的，有兴趣可以看一下</p><p>我这边最终用的是 <a href="https://github.com/ppoffice/hexo-theme-icarus">Icarus</a> 作为设计师出身的我必须对这款主题的作者表达敬意～</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>安装主题的方法就是一句git命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus.git themes&#x2F;icarus</span><br></pre></td></tr></table></figure></p><h3 id="更改-config-yml文件"><a href="#更改-config-yml文件" class="headerlink" title="更改_config.yml文件"></a>更改_config.yml文件</h3><p>将博客根目录下的_config.yml中的主题设置改为<code>icarus</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: icarus</span><br></pre></td></tr></table></figure></p><h3 id="运行本地服务"><a href="#运行本地服务" class="headerlink" title="运行本地服务"></a>运行本地服务</h3><p>最后，请使用如下命令来启动Hexo本地测试服务器，即可看见结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><p>1.修改主题为中文语言，修改的是Hexo目录下_config.yml的language，并不是theme文件下的_config.yml</p><p>2.主页文章的顶部展示图，需要在文章的头部添加 <code>thumbnail</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 文章名 </span><br><span class="line">date: 2018-12-22 18:33:58 </span><br><span class="line">categories: Hexo</span><br><span class="line">tags: tag1</span><br><span class="line">thumbnail: &#39;http:&#x2F;&#x2F;imagesUrl&#39;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>3.检索搜索功能如果出现混乱，比如删除新增过不同标签分类或文章，只要重新执行hexo clean + hexo generate即可</p><h2 id="4-部署在GitHub"><a href="#4-部署在GitHub" class="headerlink" title="4.部署在GitHub"></a>4.部署在GitHub</h2><ul><li>首先注册一个 GitHub 帐号，在第一步准备工作已经提到</li></ul><p>注册帐号就不多啰嗦了</p><p><br></p><ul><li>建立与你用户名对应的仓库，仓库名必须为&lt;your_user_name.github.com&gt;</li></ul><p>首先 Create a new repository，新建一个仓库，名字为&lt;自己的用户名+github.io&gt;</p><!-- ![](http://plvpla6dg.bkt.clouddn.com/1548407616%281%29.png) --><p><br></p><ul><li>添加SSH公钥到 Account settings -&gt; SSH Keys -&gt; Add SSH Key</li></ul><p>打开cmd命令行或者鼠标右键git bash，设置你的用户名和密码，与GitHub一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;xxx@163.com&quot;</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br></pre></td></tr></table></figure><br>生成密钥，中间连续3次Enter键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xx.com&quot;</span><br></pre></td></tr></table></figure></p><p>.ssh目录会生成id_rsa和id_rsa.pub两个文件，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</p><p>如果之前此电脑已经生成过密钥，根据提示在overwrite的时候选择 y 覆盖即可</p><!-- ![](http://plvpla6dg.bkt.clouddn.com/20160924224629087.jpg) --><p>点击页面顶部右边自己头像下的<code>Settings</code>，选择<code>SSH and GPG keys</code>，随后点击SSH一栏的<code>New SSH key</code>，title可以自行填写</p><!-- ![](http://plvpla6dg.bkt.clouddn.com/1548406679%281%29.png) --><p>最后可以验证一下,执行该命令，输入yes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>输出如下，则表示通过了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><h2 id="上传Hexo到Github"><a href="#上传Hexo到Github" class="headerlink" title="上传Hexo到Github"></a>上传Hexo到Github</h2><h3 id="安装deployer插件"><a href="#安装deployer插件" class="headerlink" title="安装deployer插件"></a>安装deployer插件</h3><p>npm如果安装失败，可以试试淘宝镜像cnpm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install –save hexo-deployer-git</span><br></pre></td></tr></table></figure></p><h3 id="修改Hexo文件下的-config-yml"><a href="#修改Hexo文件下的-config-yml" class="headerlink" title="修改Hexo文件下的_config.yml"></a>修改Hexo文件下的_config.yml</h3><p>页面最下方，找到deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;你的用户名&#x2F;你的用户名.github.io.git,master</span><br></pre></td></tr></table></figure></p><h3 id="执行发布命令"><a href="#执行发布命令" class="headerlink" title="执行发布命令"></a>执行发布命令</h3><p>记得每一次发布前，执行一次 hexo generate 命令，输出新的静态网页内容目录，再执行deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><br>按要求输入GitHub的帐号密码</p><p>如下图的结果，表示发布成功，浏览器打开 &lt;你的用户名.github.io&gt; 查看结果</p><!-- ![](http://plvpla6dg.bkt.clouddn.com/1548409749%281%29.png) --><h2 id="进阶内容"><a href="#进阶内容" class="headerlink" title="进阶内容"></a>进阶内容</h2><h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>评论功能使用的是 Valine ，我们需要先注册 <a href="https://github.com/ppoffice/hexo-theme-icarus">LeanCloud</a></p><p>其次找到theme文件下的icarus中的config.yml文件</p><h3 id="修改主题页面"><a href="#修改主题页面" class="headerlink" title="修改主题页面"></a>修改主题页面</h3><p>.git文件为隐藏文件<br>同步themes主题下的文件至github <a href="https://www.cnblogs.com/howdop/p/5583342.html">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将基于Hexo构建博客网站，替换theme主题为Icarus，最后通过Github部署发布，这样可以通过Github分发的网站链接进行访问，&lt;br&gt;当然也可以自己购买域名和服务器进行部署，但此文暂时不涉及这部分内容&lt;br&gt;
    
    </summary>
    
      <category term="原创文章" scheme="https://panpanson.github.io/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Hexo" scheme="https://panpanson.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://panpanson.github.io/2019/01/16/git/"/>
    <id>https://panpanson.github.io/2019/01/16/git/</id>
    <published>2019-01-16T03:00:24.000Z</published>
    <updated>2020-07-12T14:02:47.310Z</updated>
    
    <content type="html"><![CDATA[<p>Git常用命令</p><a id="more"></a><p>创建并切换到新分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newBranch</span><br></pre></td></tr></table></figure><br>更新提交分支代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m&#39;update&#39;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><br>版本回退<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert -n 版本号</span><br><span class="line">git commit -m&#39;update&#39;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><br>强制回退<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br><span class="line">git push -f -u origin master</span><br></pre></td></tr></table></figure><br>初始化git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init &#x2F;&#x2F;在当前的项目目录中生成本地的git管理</span><br><span class="line">git add .  &#x2F;&#x2F;将文件保存到缓存区,git add -A 将增、删、改的文件改动全保存至缓存区</span><br><span class="line">git commit -m &quot;描述&quot; &#x2F;&#x2F;将代码从缓存区保存至本地仓库</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;仓库地址.git </span><br><span class="line">&#x2F;&#x2F;将本地仓库与指定的远程仓库联系,origin是仓库名字，可以改</span><br><span class="line">git push -u origin master &#x2F;&#x2F;将本地仓库代码推送至远程仓库</span><br></pre></td></tr></table></figure><br>当git无法添加某文件夹下文件时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;directory为子文件夹的路径</span><br><span class="line">git rm --cached directory</span><br><span class="line">git add directory</span><br></pre></td></tr></table></figure><br>执行git rm –cached directory时若提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: Unable to create &#39;xx&#x2F;.git&#x2F;index.lock&#39;: File exists.</span><br></pre></td></tr></table></figure><br>则执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f xx&#x2F;.git&#x2F;index.lock</span><br></pre></td></tr></table></figure></p><p><a href="https://juejin.im/post/5eb2d6bce51d454d9d3ed14f">git命令指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git常用命令&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="https://panpanson.github.io/2018/10/21/frontInterview/"/>
    <id>https://panpanson.github.io/2018/10/21/frontInterview/</id>
    <published>2018-10-21T07:40:27.000Z</published>
    <updated>2021-08-17T15:20:32.361Z</updated>
    
    <content type="html"><![CDATA[<p>前端面试题目，持续更新</p><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="你是如何理解-HTML-语义化的？"><a href="#你是如何理解-HTML-语义化的？" class="headerlink" title="你是如何理解 HTML 语义化的？"></a>你是如何理解 HTML 语义化的？</h3><ol><li>最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。<br>后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。<br>再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签<br>语义化的好处是已读、有利于SEO等。<br><br></li><li><a href="https://zhuanlan.zhihu.com/p/32570423">知乎 - 初探 · HTML5语义化</a></li></ol><h3 id="说说盒模型"><a href="#说说盒模型" class="headerlink" title="说说盒模型"></a>说说盒模型</h3><ul><li><p>举例：<br>标准盒模型(box-sizing: content-box)：width == 内容区宽度<br>IE盒模型(box-sizing: border-box): width == 内容区宽度 + padding 宽度 + border 宽度<br>高度以此类推。</p></li><li><p>js获取盒模型宽高<br>假设已经获取的节点为 <code>dom</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能获取内联样式设置的宽高</span></span><br><span class="line">dom.style.width/height</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取渲染后即时运行的宽高，值是准确的。但只支持 IE</span></span><br><span class="line">dom.currentStyle.width/height</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取渲染后即时运行的宽高，值是准确的。兼容性更好</span></span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(dom).width/height</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取渲染后即时运行的宽高，值是准确的。兼容性也很好，一般用来获取元素的绝对位置，getBoundingClientRect()会得到4个值：left, top, width, height</span></span><br><span class="line">dom.getBoundingClientRect().width/height</span><br></pre></td></tr></table></figure></li></ul><h3 id="css-reset-和-normalize-css-有什么区别？"><a href="#css-reset-和-normalize-css-有什么区别？" class="headerlink" title="css reset 和 normalize.css 有什么区别？"></a>css reset 和 normalize.css 有什么区别？</h3><ul><li>reset 重置，之前的样式我不要，抛弃默认样式</li><li>normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一</li></ul><h3 id="如何居中？"><a href="#如何居中？" class="headerlink" title="如何居中？"></a>如何居中？</h3><h3 id="选择器优先级如何确定？"><a href="#选择器优先级如何确定？" class="headerlink" title="选择器优先级如何确定？"></a>选择器优先级如何确定？</h3><ol><li>选择器越具体，优先级越高。 #xxx 大于 .yyy</li><li>同样优先级，写在后面的覆盖前面的</li><li>color: red !important; 优先级最高</li></ol><h3 id="BFC-是什么？"><a href="#BFC-是什么？" class="headerlink" title="BFC 是什么？"></a>BFC 是什么？</h3><p>BFC : Block Formatting Context，块级格式化上下文，可以理解为是一种属性，这种属性影响着元素等定位以及其兄弟元素之间等相互作用。</p><ul><li>BFC 区域不会与 float box 重叠</li><li>BFC 是页面上的一个独立容器，子元素不会影响到外面</li><li>计算 BFC 高度时，浮动元素也会参与计算<br>生成条件:</li><li>float 除 <code>none</code> 之外的值</li><li>position 为 <code>fixed</code> 和 <code>absolute</code> 的元素</li><li>display 为 <code>inline-block</code> 、 <code>table-cell</code> 、 <code>table-caption</code> 、 <code>flex</code> 、 <code>inline-flex</code> 的元素</li><li>overflow 不为 <code>visible</code> 的元素 (比如 : hidden 、 scroll 、 auto)<br>例子:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 20px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 50px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述代码他们的边距并不是 20 + 50 ，而是发生了重叠，取最大值50 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如何解决边距问题，创建BFC，给第二个div添加父元素，在父元素上生成BFC --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 20px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"over-flow: hidden;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 50px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="如何清除浮动？"><a href="#如何清除浮动？" class="headerlink" title="如何清除浮动？"></a>如何清除浮动？</h3><ol><li><p>overflow: hidden （不建议使用）</p></li><li><p>.clearfix 清除浮动写在父级身上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">''</span>; </span><br><span class="line">   <span class="attribute">display</span>: block; </span><br><span class="line">   <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">   <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/* IE 兼容 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="JS-有哪些数据类型？"><a href="#JS-有哪些数据类型？" class="headerlink" title="JS 有哪些数据类型？"></a>JS 有哪些数据类型？</h3><p>  string number bool undefined null object symbol bigInt<br>  object 包括了数组、函数、正则、日期等对象</p><h3 id="Promise-怎么使用？"><a href="#Promise-怎么使用？" class="headerlink" title="Promise 怎么使用？"></a>Promise 怎么使用？</h3><ul><li>then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(...).then(成功函数, 失败函数)</span><br></pre></td></tr></table></figure></li><li>链式 then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(...).then(成功函数, 失败函数).then(成功函数2, 失败函数2)</span><br></pre></td></tr></table></figure></li><li>如何自己生成 Promise 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        resolve() <span class="comment">//成功  </span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject() <span class="comment">//失败</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">xxx().then(...).catch(...)</span><br></pre></td></tr></table></figure></li></ul><h3 id="手写原生AJAX"><a href="#手写原生AJAX" class="headerlink" title="手写原生AJAX"></a>手写原生AJAX</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'POST'</span>,<span class="string">'/url'</span>)</span><br><span class="line">xhr.send(<span class="string">'a=1'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.readyStatus === <span class="number">200</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><p>函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'something'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 因为func1引用了它外层的变量a，因此func成为了闭包</span></span><br><span class="line">  &#125;</span><br><span class="line">  func1()</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><br>避免闭包导致内存泄漏的解决方法是，在相关函数执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。</p><p><strong>闭包优点</strong></p><ul><li>可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</li><li>避免变量污染全局</li><li>把变量存到独立的作用域，作为私有成员存在</li></ul><p><strong>应用场景</strong></p><ul><li>典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局</li><li>在循环中创建闭包，防止取到意外的值。<br>如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'id'</span> + i).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用闭包解决</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(num);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'id'</span> + i).onfocus = makeCallback(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="这段代码里的-this-是什么？"><a href="#这段代码里的-this-是什么？" class="headerlink" title="这段代码里的 this 是什么？"></a>这段代码里的 this 是什么？</h3><ol><li>fn() 里面的 this 就是 window</li><li>fn() 是 strict mode(严格模式)，this 就是 undefined</li><li>a.b.c.fn() 里面的 this 就是 a.b.c</li><li>new F() 里面的 this 就是新生成的实例</li><li>() =&gt; console.log(this) 里面 this 跟外面的 this 的值一模一样，永远取它上级作用域的this</li></ol><p>参考：<a href="https://zhuanlan.zhihu.com/p/23804247">知乎 - this 的值到底是什么？一次说清楚</a></p><h3 id="什么是立即执行函数？使用立即执行函数的目的是什么？"><a href="#什么是立即执行函数？使用立即执行函数的目的是什么？" class="headerlink" title="什么是立即执行函数？使用立即执行函数的目的是什么？"></a>什么是立即执行函数？使用立即执行函数的目的是什么？</h3><h3 id="async-await-语法了解吗？目的是什么？"><a href="#async-await-语法了解吗？目的是什么？" class="headerlink" title="async/await 语法了解吗？目的是什么？"></a>async/await 语法了解吗？目的是什么？</h3><h3 id="如何实现数组去重？"><a href="#如何实现数组去重？" class="headerlink" title="如何实现数组去重？"></a>如何实现数组去重？</h3><h3 id="观察者模式-vs-发布-订阅模式"><a href="#观察者模式-vs-发布-订阅模式" class="headerlink" title="观察者模式 vs 发布-订阅模式"></a>观察者模式 vs 发布-订阅模式</h3><p><a href="https://juejin.im/post/5a14e9edf265da4312808d86">观察者模式 vs 发布-订阅模式</a></p><h3 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h3><p><a href="https://juejin.im/post/5e75e22951882549027687f9">JS继承</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="comment">//构造继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"><span class="comment">//寄生组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My grade is "</span> + <span class="keyword">this</span>.grade + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型式继承</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent)</span><br><span class="line"><span class="comment">//寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(orginal)</span><br><span class="line">  clone.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//混入方式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  OtherParent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line"><span class="built_in">Object</span>.assign(Child.prototype, OtherParent.prototype)</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure></p><h3 id="CSRF-XSS"><a href="#CSRF-XSS" class="headerlink" title="CSRF XSS"></a>CSRF XSS</h3><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF（Cross-site request forgery）跨站请求伪造。</p><h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；<br>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；<br>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；<br>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行</p><h5 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h5><ul><li>验证 HTTP Referer 字段；Referer 来判断该请求是否为第三方网站发起的</li><li>在请求地址中添加 token 并验证；由服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效</li><li>在 HTTP 头中自定义属性并验证；可以对 Cookie 设置 SameSite 属性，该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击</li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS（cross-site scripting）跨域脚本攻击</p><h5 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h5><p><strong>存储型</strong>：<br>1.攻击者将恶意代码提交到目标网站的数据库中<br>2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p><p><strong>反射型</strong>：<br>1.攻击者构造出特殊的 URL，其中包含恶意代码<br>2.用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里</p><p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p><p><strong>DOM型</strong>：<br>1.攻击者构造出特殊的 URL，其中包含恶意代码<br>2.用户打开带有恶意代码的 URL<br>3.用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p><h5 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h5><ul><li>HTML：对以下敏感字符进行转义：&amp;  &lt;  &gt; ‘ “ /</li><li>Javascript：把所有非字母、数字的字符都转义成小于256的ASCII字符</li><li>URL：使用Javascript的encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：,  /  ?  :  @  &amp;  =  +  $  #</li><li>设置httpOnly</li><li>开启CSP，即开启白名单，可阻止白名单以外的资源加载和运行</li></ul><h3 id="请用一句话描述-try-catch-能捕获到哪些-JS-异常"><a href="#请用一句话描述-try-catch-能捕获到哪些-JS-异常" class="headerlink" title="请用一句话描述 try catch 能捕获到哪些 JS 异常"></a>请用一句话描述 try catch 能捕获到哪些 JS 异常</h3><p>能被 try catch 捕捉到的异常，必须是在报错的时候，线程执行已经进入 try catch 代码块，且处在 try catch 里面，这个时候才能被捕捉到<br><a href="https://juejin.im/post/5ea8e2d65188256d8d605b2d">try catch能捕获到哪些JS异常</a></p><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><h4 id="DOM事件的具体捕获流程"><a href="#DOM事件的具体捕获流程" class="headerlink" title="DOM事件的具体捕获流程"></a>DOM事件的具体捕获流程</h4><p>捕获的流程为：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素<br>冒泡的流程为：目标元素-&gt; … -&gt; body -&gt; html -&gt; document -&gt; window</p><h4 id="event对象常见使用"><a href="#event对象常见使用" class="headerlink" title="event对象常见使用"></a>event对象常见使用</h4><p>1.event.preventDefault()<br>取消事件的默认动作<br>2.event.stopPropagation()<br>阻止事件冒泡<br>3.event.stopImmediatePropagation()<br>阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他的两个事件将不会被执行</p><h4 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h4><p>true表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件<br>false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</p><h3 id="前端跨域"><a href="#前端跨域" class="headerlink" title="前端跨域"></a>前端跨域</h3><p><a href="https://segmentfault.com/a/1190000011145364">前端跨域</a></p><h3 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h3><p>1.资源压缩合并，减少 HTTP 请求<br>2.非核心代码异步加载（异步加载的方式，异步加载的区别）<br>3.利用浏览器缓存（缓存的分类，缓存原理）<br>4.使用 CDN<br>5.预解析 DNS<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//强制打开 <span class="tag">&lt;<span class="name">a</span>&gt;</span> 标签的 dns 解析</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-controller"</span> <span class="attr">content</span>=<span class="string">"on"</span>&gt;</span></span><br><span class="line">//DNS预解析</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//host_name_to_prefetch.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h4><p>异步加载的方式：1.动态脚本加载 2.defer 3.async<br>异步加载的区别：<br>1.defer 浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。defer脚本会在 <code>DOMContentLoaded</code> 和 <code>load</code> 事件之前执行<br>2.async 同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于script有先后依赖关系的情况，并不适用。async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序</p><p><img src="/images/171d353539501527.webp"></p><h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</strong>也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。<br><strong>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</strong><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。<br><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。<br><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。<br><strong>s-maxage</strong>：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</p><h5 id="Expires和Cache-Control两者对比"><a href="#Expires和Cache-Control两者对比" class="headerlink" title="Expires和Cache-Control两者对比"></a>Expires和Cache-Control两者对比</h5><p>其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，<strong>两者同时存在的话，Cache-Control优先级高于Expires</strong>；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified</li><li>协商缓存失效，返回200和请求结果</li></ul><p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p><h5 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h5><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified 的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code>；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</p><p>if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。</p><ul><li>如果没有被修改：则开始`继续’传送文件，服务器返回: 200 OK</li><li>如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)</li></ul><p><strong>但是 Last-Modified 存在一些弊端：</strong></p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match</p><h5 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h5><p><strong>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</strong>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><h5 id="Last-Modified和ETag两者对比"><a href="#Last-Modified和ETag两者对比" class="headerlink" title="Last-Modified和ETag两者对比"></a>Last-Modified和ETag两者对比</h5><ul><li>首先在精确度上，Etag要优于Last-Modified。<br>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li><li>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li><li>第三在优先级上，服务器校验优先考虑Etag</li></ul><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p><h4 id="缓存场景"><a href="#缓存场景" class="headerlink" title="缓存场景"></a>缓存场景</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新</li><li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><h3 id="如何解决a标点击后hover事件失效"><a href="#如何解决a标点击后hover事件失效" class="headerlink" title="如何解决a标点击后hover事件失效"></a>如何解决a标点击后hover事件失效</h3><p>只需要记住<code>LoVe HAte</code>原则就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link→visited→hover→active</span><br></pre></td></tr></table></figure></p><h3 id="CommonJS和ES6模块的区别"><a href="#CommonJS和ES6模块的区别" class="headerlink" title="CommonJS和ES6模块的区别"></a>CommonJS和ES6模块的区别</h3><ul><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li><li>CommonJS 模块输出的是一个值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；ES6 模块输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li><li>CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li><li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li></ul><p>(前端模块化：CommonJS,AMD,CMD,ES6)[<a href="https://juejin.im/post/5aaa37c8f265da23945f365c]">https://juejin.im/post/5aaa37c8f265da23945f365c]</a></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>相对于HTTP1.1，HTTP2的优化：</p><ul><li>HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送</li><li>HTTP2支持多路复用（一次 TCP 连接可以处理多个请求）</li><li>HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积</li><li>HTTP2支持服务端推送</li></ul><p>HTTP 与 HTTPS 的区别</p><ul><li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li><li>HTTP 的端口号是 80，HTTPS 是 443</li><li>HTTPS 需要到 CA 申请证书</li><li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</li></ul><p>HTTPS：HTTP + TLS（ 非对称加密 与 对称加密 ）</p><ul><li>客户端发出 https 请求，请求服务端建立 SSL 连接</li><li>服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端</li><li>客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥</li><li>客户端将公钥与客户端私钥进行非对称加密后传给服务端</li><li>服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥</li><li>服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端</li><li>客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容</li></ul><p>(HTTPS面试问答)[<a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.md]">https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.md]</a><br>(一个故事讲完https)[<a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA]">https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA]</a></p><h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><p>TCP/IP协议族按层次分别分为以下四层：应用层、传输层、网络层和数据链路层，TCP和UDP是指传输层两个性质不同的协议。</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><ul><li>基于流的方式</li><li>面向连接</li><li>丢包重传</li><li>保证数据顺序</li><li>确保数据能到达目标</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。</p><ul><li>UDP 是非连接的协议，也就是不会跟终端建立连接</li><li>UDP 包信息只有 8 个字节</li><li>UDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界</li><li>UDP 可能丢包</li><li>UDP 不保证数据顺序</li></ul><h3 id="TCP-三次握手-四次挥手"><a href="#TCP-三次握手-四次挥手" class="headerlink" title="TCP 三次握手 四次挥手"></a>TCP 三次握手 四次挥手</h3><p>三次握手:</p><ul><li>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li><li>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li><li>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li></ul><p>四次挥手:</p><ul><li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送，客户端进入FIN-WAIT-1</li><li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号，服务端进入CLOSED-WAIT，客户端收到ACK后进入FIN-WAIT-2</li><li>服务器关闭客户端的连接，发送一个FIN给客户端，进入LAST-ACK阶段，收到客户端ACK报文后进入CLOSED</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1，客户端进入TIME-WAIT，等待2MSL后进入CLOSED</li></ul><h3 id="如何避免重排和重绘"><a href="#如何避免重排和重绘" class="headerlink" title="如何避免重排和重绘"></a>如何避免重排和重绘</h3><p>CSS：</p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上</li><li>避免使用CSS表达式（例如：calc()）</li><li>CSS3硬件加速（GPU加速）</li></ul><p>JavaScript：</p><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</li></ul><h3 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h3><p>JavaScript的运行机制:<br>1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>2.主线程之外，还存在”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>3.一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>4.主线程不断重复上面的第三步</p><p>概括即是: 调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作</p><p>JavaScript中有两种异步任务:</p><ul><li>宏任务： script （主代码块）、<code>setTimeout</code> 、<code>setInterval</code> 、<code>setImmediate</code> 、I/O 、UI rendering</li><li>微任务：<code>process.nextTick</code>（Nodejs） 、<code>Promise</code> 、<code>Object.observe</code> 、<code>MutationObserver</code></li></ul><p><strong>事件循环(event-loop)是什么？</strong></p><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行。</p><p>详细说明：</p><ul><li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会跳转至microtask的执行步骤。</li><li>将事件循环的当前运行宏任务设置为已选择的宏任务。</li><li>运行宏任务。</li><li>将事件循环的当前运行任务设置为null。</li><li>将运行完的宏任务从宏任务队列中移除。</li><li>microtasks步骤：进入microtask检查点。</li><li>更新界面渲染。</li><li>返回第一步。</li></ul><h3 id="Node的Event-Loop"><a href="#Node的Event-Loop" class="headerlink" title="Node的Event Loop"></a>Node的Event Loop</h3><ul><li>timers: 执行setTimeout和setInterval中到期的callback。</li><li>pending callback: 上一轮循环中少数的callback会放在这一阶段执行。</li><li>idle, prepare: 仅在内部使用。</li><li>poll: 最重要的阶段，执行pending callback，在适当的情况下回阻塞在这个阶段。</li><li>check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。</li><li>close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。</li></ul><h3 id="说一说从输入URL到页面呈现发生了什么"><a href="#说一说从输入URL到页面呈现发生了什么" class="headerlink" title="说一说从输入URL到页面呈现发生了什么"></a>说一说从输入URL到页面呈现发生了什么</h3><p>1.在浏览器地址栏内按下第一个键后浏览器会调用自己的算法，去书签栏或者历史记录中将我们可能访问的URL显示出来</p><p>2.点击要访问的URL后，浏览器会先检测URL是否合法，如果没问题会调用网络线程来准备发送网络请求</p><p>3.先在HTTP应用层内构建请求行，但不会发送网络请求，会先在强缓存中查找强缓存是否有效</p><p>4.强缓存无效的话，就会调用DNS域名解析将URL解析成IP地址</p><p>5.此时进入TCP传输层，进行TCP三次握手，握手完毕后将请求报文分割并打上标记生成数据包，将处理后的数据包转发给网络层</p><p>6.网络层拿到数据包后，调用ARP协议，通过IP地址反查出MAC地址</p><p>7.拿到IP地址、MAC地址、数据包后，在数据链路层内发起请求</p><p>8.服务端收到请求后，一层层的将报文剥开，其中就会把在传输层分割的报文组装起来，接着对请求会进行校验，比如是否有缓存字段、请求是否有权限。如果缓存有效，那么就会返回304状态码提醒浏览器使用缓存，这里其实就是协商缓存的步骤</p><p>9.如果缓存过期或者没设置，那么服务端就会返回请求的文件，如HTML、CSS和JS文件，浏览器接收到文件后，服务器会检测报文中的Connection的值是否等于keepw-alive，如果不是keep-alive就会断开链接，但在HTTP 1.1协议后，Connection默认为keep-alive</p><p>10.浏览器接收到HTML文件后就会进行处理，这个过程是交给渲染引擎的GUI线程来做，根据HTML文件中定义的charset和doctype来解析文档，GUI线程调用标记化算法和建树算法，实际上就是词法分析和语法分析，生成以document为根节点的DOM树</p><p>11.CSS的解析也是同理，只不过会先将CSS文件格式化成styleSheet对象，然后标准化这个对象，比如color: red这个属性会被格式化成16进制的数，最后将计算的结果挂载到window.getStyleComputed上，我们可以通过JS代码访问，但会引起回流</p><p>12.CSS解析和HTML解析互不干扰，但JS文件就会造成阻塞，因为渲染引擎中的JS线程和GUI线程是互斥的，且JS引擎的优先级比GUI线程高，会将GUI线程挂起，所以script会阻塞页面解析，要放在底部，而link CSS在头部</p><p>13.在拿到CSSOM树和DOM树后，会将二者合成为布局树，精确的计算出每一个节点所处的位置以及样式</p><p>14.浏览器在渲染前会进行图层处理，图层分为普通图层和复杂图层，而普通文档流内所有的元素所处的就是一个复杂图层，每个复杂图层都会被GPU单独绘制，所以它们之间的重绘不会影响其他图层，提成为复杂图层的方式有：</p><ul><li>1.拥有层叠上下文的特点，如scroll</li><li>2.设置z-index</li></ul><p>但要注意设置z-index的元素如果本身层叠上下文的等级就比较低，会引起层爆炸，在它上面的图层都会被提升成复杂图层，页面可能会崩溃</p><p>15.将绘制指令传入渲染队列中，通过合成线程生成图块和位图，开始渲染页面，所以常说要尽量使用opacity transform等属性，因为它们会调用GPU单独绘制，也就是所谓的硬件加速</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程：资源分配的最小单位</p><p>线程：资源调度的最小单位</p><h3 id="首屏加载优化有哪些方案"><a href="#首屏加载优化有哪些方案" class="headerlink" title="首屏加载优化有哪些方案"></a>首屏加载优化有哪些方案</h3><ul><li>Vue-Router路由懒加载（利用Webpack的代码切割）</li><li>使用CDN加速，将通用的库从vendor进行抽离</li><li>Nginx的gzip压缩</li><li>Vue异步组件</li><li>服务端渲染SSR</li><li>如果使用了一些UI库，采用按需加载</li><li>Webpack开启gzip压缩</li><li>如果首屏为登录页，可以做成多入口</li><li>Service Worker缓存文件处理</li><li>使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li></ul><h3 id="谈谈你对作用域链的理解"><a href="#谈谈你对作用域链的理解" class="headerlink" title="谈谈你对作用域链的理解"></a>谈谈你对作用域链的理解</h3><p>了解作用域链之前我们要知道一下几个概念：</p><ul><li>函数的生命周期</li><li>变量和函数的声明</li><li>Activetion Object（AO）、Variable Object（VO）</li></ul><p>函数的生命周期：</p><ul><li>创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。</li><li>执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。</li></ul><p>变量和函数的声明：如果变量名和函数名声明时相同，函数优先声明。</p><p>Activetion Object（AO）、Variable Object（VO）：</p><ul><li>AO：Activetion Object（活动对象）</li><li>VO：Variable Object（变量对象）</li></ul><p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p><ul><li>变量 (var, 变量声明);</li><li>函数声明 (FunctionDeclaration, 缩写为FD);</li><li>函数的形参</li></ul><p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p><ul><li>函数的所有局部变量</li><li>函数的所有命名参数</li><li>函数的参数集合</li><li>函数的this指向</li></ul><p>作用域链：</p><p>当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。<br>在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：<strong>有没有创建一个文档树之外的元素。</strong><br>CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>容器的属性: </p><ul><li>flex-direction 属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap 属性定义，如果一条轴线排不下，如何换行</li><li>flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li><li>justify-content 属性定义了项目在主轴上的对齐方式。</li><li>align-items 属性定义项目在交叉轴上如何对齐</li><li>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>项目的属性:</p><ul><li>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li><li>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</li></ul><h3 id="简单介绍一下-V8-引擎的垃圾回收机制"><a href="#简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="简单介绍一下 V8 引擎的垃圾回收机制"></a>简单介绍一下 V8 引擎的垃圾回收机制</h3><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p><p>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</p><p>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</p><p>（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</p><p>（2）如果对象不存活，则释放对象的空间。</p><p>（3）最后将 From 空间和 To 空间角色进行交换。</p><p>新生代对象晋升到老生代有两个条件：</p><p>（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</p><p>（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</p><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p><p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p><h3 id="JS自定义事件"><a href="#JS自定义事件" class="headerlink" title="JS自定义事件"></a>JS自定义事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建事件对象：</span></span><br><span class="line"><span class="keyword">let</span> ev = <span class="built_in">document</span>.createEvent(<span class="string">'CustomEvent'</span>)</span><br><span class="line"><span class="comment">//初始化事件对象：事件的类型名称/一个布尔值,表明该事件是否会冒泡/一个布尔值,表明该事件是否可以被取消/当事件初始化时传递的数据</span></span><br><span class="line">ev.initCustomEvent(<span class="string">'ev'</span>, <span class="literal">false</span>, <span class="literal">true</span>, &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">//监听事件：</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'ev'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(e.detail.b) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.dispatchEvent(ev)</span><br></pre></td></tr></table></figure><h3 id="ES6-symbol理解及使用场景"><a href="#ES6-symbol理解及使用场景" class="headerlink" title="ES6 symbol理解及使用场景"></a>ES6 symbol理解及使用场景</h3><p>1: 使用Symbol来作为对象属性名(key)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'name'</span>)]: <span class="string">'pan'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  title: <span class="string">'Engineer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)   <span class="comment">// ['age', 'title']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(p)   <span class="comment">// 分别会输出：'age' 和 'title'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)   <span class="comment">// ['age', 'title']</span></span><br></pre></td></tr></table></figure><br>Symbol类型的key是不能通过<code>Object.keys()</code>或者<code>for...in</code>来枚举的，所以利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(obj)  <span class="comment">// &#123;"age":27,"title":"Engineer"&#125;</span></span><br></pre></td></tr></table></figure><p>当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外,<br>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p><p>可以通过特定的Api获取Symbol定义的对象属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Object的API</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新增的反射API</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// [Symbol(name), 'age', 'title']</span></span><br></pre></td></tr></table></figure></p><p>2: 使用Symbol来替代常量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="string">'AUDIO'</span></span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="string">'VIDEO'</span></span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="string">'IMAGE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了Symbol，直接定义就保证了三个常量的值是唯一的</span></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure></p><p>3: 使用Symbol定义类的私有属性/方法</p><ul><li><p>在a.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PASSWORD = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(username, password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPassword(pwd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br></pre></td></tr></table></figure></li><li><p>在b.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> Login(<span class="string">'admin'</span>, <span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line">login.checkPassword(<span class="string">'123456'</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">login.PASSWORD  <span class="comment">// oh!no!</span></span><br><span class="line">login[PASSWORD] <span class="comment">// oh!no!</span></span><br><span class="line">login[<span class="string">"PASSWORD"</span>] <span class="comment">// oh!no!</span></span><br></pre></td></tr></table></figure></li></ul><p>由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p><p>4: 注册和获取全局Symbol<br><code>Symbol.for()</code>它可以注册或获取一个window间全局的Symbol实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gs1 = <span class="built_in">Symbol</span>.for(<span class="string">'global_symbol_1'</span>)  <span class="comment">//注册一个全局Symbol</span></span><br><span class="line"><span class="keyword">let</span> gs2 = <span class="built_in">Symbol</span>.for(<span class="string">'global_symbol_1'</span>)  <span class="comment">//获取全局Symbol</span></span><br><span class="line"></span><br><span class="line">gs1 === gs2  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p><p>参考：<br><a href="https://juejin.im/post/5eace2176fb9a04340658974">前端面试必备技巧</a><br><a href="https://www.cxymsg.com/">前端面试与进阶指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端面试题目，持续更新&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://panpanson.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="JaveScript" scheme="https://panpanson.github.io/tags/JaveScript/"/>
    
      <category term="HTML" scheme="https://panpanson.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://panpanson.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题（手写）</title>
    <link href="https://panpanson.github.io/2018/08/21/frontInterview2/"/>
    <id>https://panpanson.github.io/2018/08/21/frontInterview2/</id>
    <published>2018-08-21T07:40:27.000Z</published>
    <updated>2021-08-17T04:08:20.627Z</updated>
    
    <content type="html"><![CDATA[<p>前端面试题，手撸方向</p><a id="more"></a><h3 id="解析url的参数"><a href="#解析url的参数" class="headerlink" title="解析url的参数"></a>解析url的参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽可能全面正确的解析一个任意url的所有参数为Object</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled'</span>;</span><br><span class="line">parseParam(url);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">   user: 'anonymous',</span></span><br><span class="line"><span class="comment">   id: [123, 456], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">   city: '北京', // 中文</span></span><br><span class="line"><span class="comment">   enabled: true, // 未指定值的 key 约定值为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>解答：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = url.indexOf(<span class="string">'/?'</span>) <span class="comment">//得到url中'/?'字符的index</span></span><br><span class="line">  <span class="keyword">let</span> urlStr = url.substring(num+<span class="number">2</span>) <span class="comment">//取出url'/?'后的字符</span></span><br><span class="line">  <span class="keyword">let</span> urlArr = urlStr.split(<span class="string">'&amp;'</span>) <span class="comment">//以'&amp;'分割字符串，存储到数组中</span></span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;</span><br><span class="line">  urlArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">if</span> (item.indexOf(<span class="string">'='</span>) != <span class="number">-1</span>) &#123; <span class="comment">//判断是否有对应的value，即是否有'='</span></span><br><span class="line">      <span class="keyword">let</span> [key,val] = item.split(<span class="string">'='</span>) <span class="comment">//解构赋值，分割key和value</span></span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val) <span class="comment">//解码，转换为中文</span></span><br><span class="line">      <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="comment">//判断paramsObj是否已有对应的key</span></span><br><span class="line">        paramsObj[key] = [].concat(paramsObj[key],val) <span class="comment">//有的话就转换为数组合并</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">//没有的话就直接以对象存储</span></span><br><span class="line">        paramsObj[key] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 处理没有value的，默认约定值为true</span></span><br><span class="line">      paramsObj[item] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(paramsObj)</span><br><span class="line">&#125;</span><br><span class="line">parseParam(url)</span><br></pre></td></tr></table></figure></p><h3 id="实现一个JSONP"><a href="#实现一个JSONP" class="headerlink" title="实现一个JSONP"></a>实现一个JSONP</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONP</span>(<span class="params">url, params, callbackKey, callback</span>) </span>&#123;</span><br><span class="line">params = params || &#123;&#125;</span><br><span class="line">params[callbackKey] = <span class="string">'jsonpCallback'</span></span><br><span class="line"><span class="built_in">window</span>.jsonpCallback = callback</span><br><span class="line"><span class="comment">// 拼接参数字符串</span></span><br><span class="line"><span class="keyword">const</span> paramsKey = <span class="built_in">Object</span>.keys(params)</span><br><span class="line"><span class="keyword">const</span> paramsString = paramsKey.map(<span class="function"><span class="params">key</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>).join(<span class="string">'&amp;'</span>)</span><br><span class="line"><span class="comment">// 插入 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.setAttribute(<span class="string">'src'</span>, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramsString&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">JSONP(&#123;  </span><br><span class="line">  url: <span class="string">'http://demo.com/ajax/jsonp/suggestion'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    key: <span class="string">'test'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callbackKey: <span class="string">'_cb'</span>,</span><br><span class="line">  callback(result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现一个简单的模板引擎"><a href="#实现一个简单的模板引擎" class="headerlink" title="实现一个简单的模板引擎"></a>实现一个简单的模板引擎</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">'我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;'</span>;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  name: <span class="string">'姓名'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">render(template, data); <span class="comment">// 我是姓名，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure><p>解答：</p><ul><li>普通方式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>  <span class="comment">//模板字符串的正则表达式</span></span><br><span class="line"><span class="keyword">if</span>(reg.test(template))&#123;  <span class="comment">//模板中是否有相关字符串</span></span><br><span class="line"><span class="keyword">let</span> name = reg.exec(template)[<span class="number">1</span>] <span class="comment">//查找模板中的第一个字符串的name</span></span><br><span class="line">template = template.replace(reg,data[name]) <span class="comment">//将模板中的字符串替换为data对应的值</span></span><br><span class="line"><span class="keyword">return</span> render(template,data) <span class="comment">//递归调用并渲染余下字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(template)</span><br><span class="line"><span class="keyword">return</span> template <span class="comment">//如果没有模板字符串就直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一行代码实现方式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> template.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'&#123;&#123;(.*?)&#125;&#125;'</span>, <span class="string">'g'</span>), (match, key) =&gt; data[key.trim()])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="将一个任意长的数字变成逗号分隔的格式"><a href="#将一个任意长的数字变成逗号分隔的格式" class="headerlink" title="将一个任意长的数字变成逗号分隔的格式"></a>将一个任意长的数字变成逗号分隔的格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1234.56 =&gt; "1,234.56" , 123456789 =&gt; "123,456,789"</span></span><br><span class="line">parseToMoney(<span class="number">1234.56</span>) <span class="comment">// return "1,234.56"</span></span><br></pre></td></tr></table></figure><p>解答：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseToMoney</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">num += <span class="string">''</span> <span class="comment">//转换为字符串</span></span><br><span class="line"><span class="keyword">let</span> [integer,decimal] = num.split(<span class="string">'.'</span>) <span class="comment">//转换为整数和小数的数组</span></span><br><span class="line">integer = integer.replace(<span class="regexp">/\d(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">'$&amp;,'</span>) <span class="comment">//整数部分利用正则判断每三位数插入一个逗号</span></span><br><span class="line"><span class="keyword">return</span> integer + (decimal ? <span class="string">'.'</span> + decimal : <span class="string">''</span>) <span class="comment">//最后判断是否有小数部分进行拼接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseToMoney2</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num.toLocaleString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数据绑定的最基本实现"><a href="#数据绑定的最基本实现" class="headerlink" title="数据绑定的最基本实现"></a>数据绑定的最基本实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个方法，可以给 obj 所有的属性添加动态绑定事件，当属性值发生变化时会触发事件</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  key_1: <span class="number">1</span>,</span><br><span class="line">  key_2: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' 的值发生改变：'</span> + <span class="keyword">this</span>[key]);</span><br><span class="line">&#125;</span><br><span class="line">bindData(obj, func);</span><br><span class="line">obj.key_1 = <span class="number">2</span>; <span class="comment">// 此时自动输出 "key_1 的值发生改变：2"</span></span><br><span class="line">obj.key_2 = <span class="number">1</span>; <span class="comment">// 此时自动输出 "key_2 的值发生改变：1"</span></span><br></pre></td></tr></table></figure><p>解答：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindData</span>(<span class="params">obj,func</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line"><span class="keyword">set</span>(newVal)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.value !== newVal) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = newVal</span><br><span class="line">func.call(obj,key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">get</span>()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="递归找文件"><a href="#递归找文件" class="headerlink" title="递归找文件"></a>递归找文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现提供几个读取文件的方法，不借助全局变量实现一个函数，函数可以执行一次后返回一个目录下所有文件中是 .js 后缀的文件列表</span></span><br><span class="line"><span class="keyword">var</span> readdirSync = <span class="function"><span class="keyword">function</span>(<span class="params">dir_path</span>)</span>&#123; <span class="keyword">return</span> [filename] &#125; <span class="comment">// 读取一个文件夹下的所有文件夹和文件的路径列表（Array）</span></span><br><span class="line"><span class="keyword">var</span> isDirectory = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>; &#125; <span class="comment">// 判断一个路径是否是文件夹</span></span><br><span class="line"><span class="keyword">var</span> existsSync = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123; <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;&#125; <span class="comment">// 判断一个文件/文件夹是否存在</span></span><br><span class="line"><span class="keyword">var</span> getJSFiles = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">getJSFiles(<span class="string">'/code/'</span>); <span class="comment">// return 一个文件列表的数组</span></span><br></pre></td></tr></table></figure><p>解答:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSFiles</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">if</span>(existsSync(path)) &#123; <span class="comment">//判断文件/文件夹是否存在</span></span><br><span class="line"><span class="keyword">if</span>(isDirectory(path)) &#123; <span class="comment">//是否是文件夹</span></span><br><span class="line"> <span class="keyword">var</span> files = readdirSync(path); <span class="comment">//获取文件夹下的文件和文件夹列表</span></span><br><span class="line"> files.forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123; <span class="comment">//遍历文件和文件夹</span></span><br><span class="line"> result = result.concat(getJSFiles(file)); <span class="comment">//递归调用</span></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="regexp">/\.js$/</span>.test(path)) &#123; <span class="comment">//正则判断.js后缀文件</span></span><br><span class="line"> result.push(path); <span class="comment">//js文件插入数组</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> result; <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="转换数字到中文大写"><a href="#转换数字到中文大写" class="headerlink" title="转换数字到中文大写"></a>转换数字到中文大写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toLowerNum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="regexp">/^(0|[1-9]\d*)(\.\d+)?$/</span>.test(n))&#123; <span class="comment">//利用正则判断是否合规</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"数据非法"</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">let</span> unit = <span class="string">"千百拾亿千百拾万千百拾元角分"</span>, str = <span class="string">""</span> <span class="comment">//声明中文基和返回字符串</span></span><br><span class="line">    n += <span class="string">"00"</span> <span class="comment">//将数字转换为字符串并添加角分</span></span><br><span class="line">    <span class="keyword">let</span> p = n.indexOf(<span class="string">'.'</span>) <span class="comment">//判断是否本身就有角分位</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= <span class="number">0</span>)&#123;  <span class="comment">//有角分位</span></span><br><span class="line">    n = n.substring(<span class="number">0</span>, p) + n.substr(p+<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//重新截取数字，将小数点和拼接的'00'的去除</span></span><br><span class="line">    &#125;      </span><br><span class="line">    unit = unit.substr(unit.length - n.length) <span class="comment">//按照数字的长短截取中文基，这是关键需要理解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; n.length; i++)&#123; </span><br><span class="line">        str += <span class="string">'零壹贰叁肆伍陆柒捌玖'</span>.charAt(n.charAt(i)) + unit.charAt(i) <span class="comment">//将阿拉伯数字转换成中文数字，按位添加中文基</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/零(千|百|拾|角)/g</span>, <span class="string">"零"</span>).replace(<span class="regexp">/(零)+/g</span>, <span class="string">"零"</span>).replace(<span class="regexp">/零(万|亿|元)/g</span>, <span class="string">"$1"</span>).replace(<span class="regexp">/(亿)万|壹(拾)/g</span>, <span class="string">"$1$2"</span>).replace(<span class="regexp">/^元零?|零分/g</span>, <span class="string">""</span>).replace(<span class="regexp">/元$/g</span>, <span class="string">"元整"</span>) <span class="comment">//利用正则替换语义不恰当的中文基</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个函数，可以判断a字符串是否被包含在b字符串中"><a href="#实现一个函数，可以判断a字符串是否被包含在b字符串中" class="headerlink" title="实现一个函数，可以判断a字符串是否被包含在b字符串中"></a>实现一个函数，可以判断a字符串是否被包含在b字符串中</h3><p>不能用原生api，自己实现一个字符串查找，这道题其实非常经典<br><a href="https://blog.csdn.net/buaa_shang/article/details/9907183">参考 - KMP算法–转</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">'34'</span>;b=<span class="string">'1234567'</span>; <span class="comment">// 返回 true</span></span><br><span class="line">a=<span class="string">'35'</span>;b=<span class="string">'1234567'</span>; <span class="comment">// 返回 false</span></span><br><span class="line">a=<span class="string">'355'</span>;b=<span class="string">'12354355'</span>; <span class="comment">// 返回 true</span></span><br><span class="line">isContain(a,b);</span><br></pre></td></tr></table></figure><br>解答：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isContain</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> b)&#123; <span class="comment">//遍历字符串b</span></span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] === b[i]) &#123; <span class="comment">//在字符串b上找到字符串a的第一个字符</span></span><br><span class="line"><span class="keyword">let</span> tmp = <span class="literal">true</span> <span class="comment">//设置一个变量，默认true</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j <span class="keyword">in</span> a)&#123; <span class="comment">//遍历字符串a</span></span><br><span class="line"><span class="keyword">if</span> (a[j] !== b[~~i + ~~j]) &#123; <span class="comment">//判断字符串a接下去字符是否有与b字符串相同（~~这里是快速将i和j转为数字进行运算）</span></span><br><span class="line">tmp = <span class="literal">false</span> <span class="comment">//如果有不相同，则变量赋值false，默认为true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp) &#123; <span class="comment">//通过遍历a字符串返回的结果，确认b中是否有a</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//有则返回true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//没有结果，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数柯理化"><a href="#函数柯理化" class="headerlink" title="函数柯理化"></a>函数柯理化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 缓存除函数fn之外的所有参数</span></span><br><span class="line"><span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 连接已缓存的老的参数和新传入的参数(即把每次传入的参数全部先保存下来，但是并不执行)</span></span><br><span class="line"><span class="keyword">let</span> newArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line"><span class="keyword">if</span> (newArgs.length &lt; fn.length) &#123;</span><br><span class="line"><span class="comment">// 累积的参数总数少于fn形参总数</span></span><br><span class="line">      <span class="comment">// 递归传入fn和已累积的参数</span></span><br><span class="line"><span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, ...newArgs)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compose组合函数"><a href="#compose组合函数" class="headerlink" title="compose组合函数"></a>compose组合函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function">(<span class="params">name</span>) =&gt;</span>  <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> toUpper = <span class="function">(<span class="params">str</span>) =&gt;</span> str.toUpperCase()</span><br><span class="line"><span class="keyword">var</span> fn = compose(toUpper, greeting)</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="string">'panson'</span>)) <span class="comment">// HELLO PANSON </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> length = args.length <span class="comment">// args函数的个数</span></span><br><span class="line"><span class="keyword">var</span> count = length - <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> result</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...args1</span>) </span>&#123;</span><br><span class="line"><span class="comment">// func函数的args1参数枚举</span></span><br><span class="line">result = args[count].apply(<span class="keyword">this</span>, args1)</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">count --</span><br><span class="line"><span class="keyword">return</span> func.call(<span class="literal">null</span>, result) <span class="comment">// result 上一个函数的返回结果</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count = length - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动实现instanceof"><a href="#手动实现instanceof" class="headerlink" title="手动实现instanceof"></a>手动实现instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断数据类型直接返回false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">'object'</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left)</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (proto == right.prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf2</span>(<span class="params">L, R</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">  <span class="keyword">var</span> O = R.prototype; <span class="comment">// 取 R 的显示原型</span></span><br><span class="line">  L = L.__proto__; <span class="comment">// 取 L 的隐式原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (O === L)</span><br><span class="line">      <span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    L = L.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>] <span class="comment">//输出[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6中的flat方法</span></span><br><span class="line">array = array.flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">//replace + split</span></span><br><span class="line">array = <span class="built_in">JSON</span>.stringify(array).replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>)</span><br><span class="line"><span class="comment">//普通递归</span></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> item = array[i]</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">fn(item)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用reduce函数迭代</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展运算符</span></span><br><span class="line"><span class="keyword">while</span> (array.some(<span class="built_in">Array</span>.isArray)) &#123;</span><br><span class="line">array = [].concat(...array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现数组map方法"><a href="#实现数组map方法" class="headerlink" title="实现数组map方法"></a>实现数组map方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">callbackFn, thisArg</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 处理数组类型异常</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot read property '</span>map<span class="string">' of null or undefined'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理回调类型异常</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackFn) !== <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 草案中提到要先转换为对象</span></span><br><span class="line"><span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">let</span> T = thisArg</span><br><span class="line"><span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Array</span>(len)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line"><span class="keyword">let</span> kValue = O[k]</span><br><span class="line"><span class="comment">// 依次传入this, 当前项，当前索引，整个数组</span></span><br><span class="line"><span class="keyword">let</span> mappedValue = callbackFn.call(T, KValue, k, O)</span><br><span class="line">A[k] = mappedValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, mapCallback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先，检查传递的参数是否正确。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length || <span class="keyword">typeof</span> mapCallback !== <span class="string">'function'</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 每次调用此函数时，我们都会创建一个 result 数组</span></span><br><span class="line">    <span class="comment">// 因为我们不想改变原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class="line">      <span class="comment">// 将 mapCallback 返回的结果 push 到 result 数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个new方法"><a href="#实现一个new方法" class="headerlink" title="实现一个new方法"></a>实现一个new方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'myNew function the first param must be a function'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line"><span class="keyword">let</span> res = fn.apply(obj, args)</span><br><span class="line"><span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; res !== <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">return</span> isObject || isFunction ? res : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> New = <span class="function"><span class="keyword">function</span>(<span class="params">Fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">// 创建空对象</span></span><br><span class="line">  <span class="keyword">var</span> arg = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  obj.__proto__ = Fn.prototype; <span class="comment">// 将obj的原型链__proto__指向构造函数的原型prototype</span></span><br><span class="line">  obj.__proto__.constructor = Fn; <span class="comment">// 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn</span></span><br><span class="line">  Fn.apply(obj, arg); <span class="comment">// 执行Fn，并将构造函数Fn执行obj</span></span><br><span class="line">  <span class="keyword">return</span> obj; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现一个call"><a href="#实现一个call" class="headerlink" title="实现一个call"></a>实现一个call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 获取参数</span></span><br><span class="line"><span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>), result = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">context = context || <span class="built_in">window</span></span><br><span class="line"><span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">context.fn = <span class="keyword">this</span></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">result = context.fn(...args)</span><br><span class="line"><span class="comment">// 将属性删除</span></span><br><span class="line"><span class="keyword">delete</span> context.fn</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个apply"><a href="#实现一个apply" class="headerlink" title="实现一个apply"></a>实现一个apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">let</span> result =<span class="literal">null</span> </span><br><span class="line"><span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">context = context || <span class="built_in">window</span></span><br><span class="line"><span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">context.fn = <span class="keyword">this</span></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = context.fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将属性删除</span></span><br><span class="line"><span class="keyword">delete</span> context.fn</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个bind方法"><a href="#实现一个bind方法" class="headerlink" title="实现一个bind方法"></a>实现一个bind方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。</span></span><br><span class="line">self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">fbound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个reduce方法"><a href="#实现一个reduce方法" class="headerlink" title="实现一个reduce方法"></a>实现一个reduce方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">arr, reduceCallback, initialValue</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || arr.length === <span class="number">0</span> || <span class="keyword">typeof</span> reduceCallback !== <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span></span><br><span class="line"><span class="keyword">let</span> hasInitialValue = initialValue !== <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = hasInitialValue ? <span class="number">0</span> : <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">value = reduceCallback(value, arr[i], i, arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个Promise"><a href="#实现一个Promise" class="headerlink" title="实现一个Promise"></a>实现一个Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">self.status = <span class="string">'pending'</span></span><br><span class="line">self.value = <span class="literal">undefined</span></span><br><span class="line">self.reason = <span class="literal">undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">self.value = value</span><br><span class="line">self.status = <span class="string">'resolved'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">self.reason = reason</span><br><span class="line">self.status = <span class="string">'rejected'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">constructor</span>(resolve, reject)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">reject(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled, onRejected</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">switch</span>(self.status) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'resolved'</span>:</span><br><span class="line">onFullfilled(self.value)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'rejected'</span>:</span><br><span class="line">onRejected(self.reason)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个Promise-all"><a href="#实现一个Promise-all" class="headerlink" title="实现一个Promise.all"></a>实现一个Promise.all</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`argument must be a array`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> resolvedCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> promiseNum = promises.length</span><br><span class="line"><span class="keyword">let</span> resolvedResult = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line"><span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">resolvedCount++</span><br><span class="line">resolvedResult[i] = value</span><br><span class="line"><span class="keyword">if</span> (resolvedCount === promiseNum) &#123;</span><br><span class="line"><span class="keyword">return</span> resolve(resolvedResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,error =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><figcaption><span>简单版 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> typeOf obj === <span class="string">'Object'</span> &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isObject(obj)) <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line"><span class="keyword">if</span> (isObject(obj[key])) &#123;</span><br><span class="line">target[key] = deepClone(obj[key])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">target[key] = obj[key]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>相对复杂版</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取数据类型</span></span><br><span class="line">  <span class="keyword">const</span> baseType = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line">    .call(data)</span><br><span class="line">    .replace(<span class="regexp">/^\[object\s(.+)\]$/g</span>, <span class="string">"$1"</span>)</span><br><span class="line">    .toLowerCase();</span><br><span class="line">  <span class="keyword">const</span> type = data <span class="keyword">instanceof</span> Element ? <span class="string">"element"</span> : baseType;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> isPrimitive = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断是否是基本数据类型</span></span><br><span class="line">  <span class="keyword">const</span> primitiveType = <span class="string">"undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset"</span>.split(</span><br><span class="line">    <span class="string">","</span></span><br><span class="line">  ); <span class="comment">// 其实还有很多类型</span></span><br><span class="line">  <span class="keyword">return</span> primitiveType.includes(getType(data));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">data</span> =&gt;</span> getType(data) === <span class="string">"object"</span>;</span><br><span class="line"><span class="keyword">const</span> isArray = <span class="function"><span class="params">data</span> =&gt;</span> getType(data) === <span class="string">"array"</span>;</span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;; <span class="comment">// 缓存值，防止循环引用</span></span><br><span class="line">  <span class="keyword">const</span> baseClone = <span class="function"><span class="params">_data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (isPrimitive(_data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(_data)) &#123;</span><br><span class="line">      res = &#123; ..._data &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(_data)) &#123;</span><br><span class="line">      res = [..._data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有复杂类型的数据，有就递归</span></span><br><span class="line">    <span class="built_in">Reflect</span>.ownKeys(res).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res[key] &amp;&amp; getType(res[key]) === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="comment">// 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题</span></span><br><span class="line">        <span class="keyword">if</span> (cache[res[key]]) &#123;</span><br><span class="line">          res[key] = cache[res[key]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cache[res[key]] = res[key];</span><br><span class="line">          res[key] = baseClone(res[key]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> baseClone(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现图片懒加载"><a href="#实现图片懒加载" class="headerlink" title="实现图片懒加载"></a>实现图片懒加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazyImage</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(el) &#123;</span><br><span class="line"><span class="keyword">this</span>.imageArr = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(el)) <span class="comment">// 取图片列表，即img标签列表</span></span><br><span class="line"><span class="keyword">this</span>.init()</span><br><span class="line">&#125;</span><br><span class="line">bindEvent() &#123;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">this</span>.main()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line"><span class="keyword">let</span> h = <span class="built_in">window</span>.innerHeight <span class="comment">// 可视区域高度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.imageArr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.imageArr[i].getBoundingClientRect().top &lt;= h) &#123;</span><br><span class="line"><span class="keyword">let</span> src = <span class="keyword">this</span>.imageArr[i].getAttribute(<span class="string">'date-src'</span>)</span><br><span class="line"><span class="keyword">this</span>.imageArr[i].src = src</span><br><span class="line"><span class="keyword">this</span>.imageArr.splice(i, <span class="number">1</span>) <span class="comment">//已加载过的从图片数组里删除掉，避免后面onscroll不必要的循环</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">init() &#123;</span><br><span class="line"><span class="keyword">this</span>.main()</span><br><span class="line"><span class="keyword">this</span>.bindEvent()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<br><figure class="highlight js"><figcaption><span>debounce</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">1000</span>, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">timeout = <span class="literal">null</span></span><br><span class="line">func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;, wait)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="并行处理多个异步函数"><a href="#并行处理多个异步函数" class="headerlink" title="并行处理多个异步函数"></a>并行处理多个异步函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [result1, result2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">otherAsyncFunc1(),</span><br><span class="line">otherAsyncFunc2()</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log(result1, result2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">otherAsyncFunc1(),</span><br><span class="line">otherAsyncFunc2()</span><br><span class="line">]).then([result1, result2] =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result1, result2)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用正则写一个根据name获取cookie中的值的方法"><a href="#用正则写一个根据name获取cookie中的值的方法" class="headerlink" title="用正则写一个根据name获取cookie中的值的方法"></a>用正则写一个根据name获取cookie中的值的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise限制并发数"><a href="#promise限制并发数" class="headerlink" title="promise限制并发数"></a>promise限制并发数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LimitPromise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span> (max) &#123;</span><br><span class="line"><span class="keyword">this</span>.max = max</span><br><span class="line"><span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line"><span class="keyword">this</span>.taskQueue = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call(caller, ...args) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> task = <span class="keyword">this</span>.createTask(caller, args, resolve, reject)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.count &gt;= <span class="keyword">this</span>.max) &#123;</span><br><span class="line"><span class="keyword">this</span>.taskQueue.push(task)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">task()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createTask(caller, args, resolve, reject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 实际上是在这里调用了异步任务，并将异步任务的返回（resolve和reject）抛给了上层</span></span><br><span class="line">caller(...args)</span><br><span class="line">.then(resolve)</span><br><span class="line">.catch(reject)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 任务队列的消费区，利用Promise的finally方法，在异步任务结束后，取出下一个任务执行</span></span><br><span class="line"><span class="keyword">this</span>.count --</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.taskQueue.length) &#123;</span><br><span class="line"><span class="keyword">let</span> task = <span class="keyword">this</span>.taskQueue.shift()</span><br><span class="line">task()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">this</span>.count ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> limitP = <span class="keyword">new</span> LimitPromise(<span class="number">10</span>)</span><br><span class="line">limitP.call(request, url, params)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端面试题，手撸方向&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://panpanson.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="JaveScript" scheme="https://panpanson.github.io/tags/JaveScript/"/>
    
  </entry>
  
</feed>
