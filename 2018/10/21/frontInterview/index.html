<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>前端面试题 - Panson的个人网站</title><meta description="前端面试题目，持续更新"><meta property="og:type" content="blog"><meta property="og:title" content="前端面试题"><meta property="og:url" content="https://panpanson.github.io/"><meta property="og:site_name" content="Panson的个人网站"><meta property="og:description" content="前端面试题目，持续更新"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.pexels.com/photos/1181263/pexels-photo-1181263.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260"><meta property="article:published_time" content="2018-10-21T07:40:27.000Z"><meta property="article:modified_time" content="2021-08-17T15:20:32.361Z"><meta property="article:author" content="Panson"><meta property="article:tag" content="JaveScript"><meta property="article:tag" content="HTML"><meta property="article:tag" content="CSS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images.pexels.com/photos/1181263/pexels-photo-1181263.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://panpanson.github.io/2018/10/21/frontInterview/"},"headline":"Panson的个人网站","image":[],"datePublished":"2018-10-21T07:40:27.000Z","dateModified":"2021-08-17T15:20:32.361Z","author":{"@type":"Person","name":"Panson"},"description":"前端面试题目，持续更新"}</script><link rel="canonical" href="https://panpanson.github.io/2018/10/21/frontInterview/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Panson的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="https://images.pexels.com/photos/1181263/pexels-photo-1181263.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260" alt="前端面试题"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-10-21T07:40:27.000Z" title="2018-10-21T07:40:27.000Z">2018-10-21</time><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">1 小时 读完 (大约 11913 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">前端面试题</h1><div class="content"><p>前端面试题目，持续更新</p>
<a id="more"></a>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="你是如何理解-HTML-语义化的？"><a href="#你是如何理解-HTML-语义化的？" class="headerlink" title="你是如何理解 HTML 语义化的？"></a>你是如何理解 HTML 语义化的？</h3><ol>
<li>最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。<br>后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。<br>再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签<br>语义化的好处是已读、有利于SEO等。<br><br></li>
<li><a href="https://zhuanlan.zhihu.com/p/32570423">知乎 - 初探 · HTML5语义化</a></li>
</ol>
<h3 id="说说盒模型"><a href="#说说盒模型" class="headerlink" title="说说盒模型"></a>说说盒模型</h3><ul>
<li><p>举例：<br>标准盒模型(box-sizing: content-box)：width == 内容区宽度<br>IE盒模型(box-sizing: border-box): width == 内容区宽度 + padding 宽度 + border 宽度<br>高度以此类推。</p>
</li>
<li><p>js获取盒模型宽高<br>假设已经获取的节点为 <code>dom</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能获取内联样式设置的宽高</span></span><br><span class="line">dom.style.width/height</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取渲染后即时运行的宽高，值是准确的。但只支持 IE</span></span><br><span class="line">dom.currentStyle.width/height</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取渲染后即时运行的宽高，值是准确的。兼容性更好</span></span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(dom).width/height</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取渲染后即时运行的宽高，值是准确的。兼容性也很好，一般用来获取元素的绝对位置，getBoundingClientRect()会得到4个值：left, top, width, height</span></span><br><span class="line">dom.getBoundingClientRect().width/height</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="css-reset-和-normalize-css-有什么区别？"><a href="#css-reset-和-normalize-css-有什么区别？" class="headerlink" title="css reset 和 normalize.css 有什么区别？"></a>css reset 和 normalize.css 有什么区别？</h3><ul>
<li>reset 重置，之前的样式我不要，抛弃默认样式</li>
<li>normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一</li>
</ul>
<h3 id="如何居中？"><a href="#如何居中？" class="headerlink" title="如何居中？"></a>如何居中？</h3><h3 id="选择器优先级如何确定？"><a href="#选择器优先级如何确定？" class="headerlink" title="选择器优先级如何确定？"></a>选择器优先级如何确定？</h3><ol>
<li>选择器越具体，优先级越高。 #xxx 大于 .yyy</li>
<li>同样优先级，写在后面的覆盖前面的</li>
<li>color: red !important; 优先级最高</li>
</ol>
<h3 id="BFC-是什么？"><a href="#BFC-是什么？" class="headerlink" title="BFC 是什么？"></a>BFC 是什么？</h3><p>BFC : Block Formatting Context，块级格式化上下文，可以理解为是一种属性，这种属性影响着元素等定位以及其兄弟元素之间等相互作用。</p>
<ul>
<li>BFC 区域不会与 float box 重叠</li>
<li>BFC 是页面上的一个独立容器，子元素不会影响到外面</li>
<li>计算 BFC 高度时，浮动元素也会参与计算<br>生成条件:</li>
<li>float 除 <code>none</code> 之外的值</li>
<li>position 为 <code>fixed</code> 和 <code>absolute</code> 的元素</li>
<li>display 为 <code>inline-block</code> 、 <code>table-cell</code> 、 <code>table-caption</code> 、 <code>flex</code> 、 <code>inline-flex</code> 的元素</li>
<li>overflow 不为 <code>visible</code> 的元素 (比如 : hidden 、 scroll 、 auto)<br>例子:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 20px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 50px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述代码他们的边距并不是 20 + 50 ，而是发生了重叠，取最大值50 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如何解决边距问题，创建BFC，给第二个div添加父元素，在父元素上生成BFC --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 20px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"over-flow: hidden;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 50px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="如何清除浮动？"><a href="#如何清除浮动？" class="headerlink" title="如何清除浮动？"></a>如何清除浮动？</h3><ol>
<li><p>overflow: hidden （不建议使用）</p>
</li>
<li><p>.clearfix 清除浮动写在父级身上</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">''</span>; </span><br><span class="line">   <span class="attribute">display</span>: block; </span><br><span class="line">   <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">   <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/* IE 兼容 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JS-有哪些数据类型？"><a href="#JS-有哪些数据类型？" class="headerlink" title="JS 有哪些数据类型？"></a>JS 有哪些数据类型？</h3><p>  string number bool undefined null object symbol bigInt<br>  object 包括了数组、函数、正则、日期等对象</p>
<h3 id="Promise-怎么使用？"><a href="#Promise-怎么使用？" class="headerlink" title="Promise 怎么使用？"></a>Promise 怎么使用？</h3><ul>
<li>then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(...).then(成功函数, 失败函数)</span><br></pre></td></tr></table></figure></li>
<li>链式 then<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(...).then(成功函数, 失败函数).then(成功函数2, 失败函数2)</span><br></pre></td></tr></table></figure></li>
<li>如何自己生成 Promise 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        resolve() <span class="comment">//成功  </span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject() <span class="comment">//失败</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">xxx().then(...).catch(...)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="手写原生AJAX"><a href="#手写原生AJAX" class="headerlink" title="手写原生AJAX"></a>手写原生AJAX</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'POST'</span>,<span class="string">'/url'</span>)</span><br><span class="line">xhr.send(<span class="string">'a=1'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.readyStatus === <span class="number">200</span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><p>函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'something'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 因为func1引用了它外层的变量a，因此func成为了闭包</span></span><br><span class="line">  &#125;</span><br><span class="line">  func1()</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><br>避免闭包导致内存泄漏的解决方法是，在相关函数执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。</p>
<p><strong>闭包优点</strong></p>
<ul>
<li>可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用</li>
<li>避免变量污染全局</li>
<li>把变量存到独立的作用域，作为私有成员存在</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局</li>
<li>在循环中创建闭包，防止取到意外的值。<br>如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'id'</span> + i).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用闭包解决</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(num);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'id'</span> + i).onfocus = makeCallback(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="这段代码里的-this-是什么？"><a href="#这段代码里的-this-是什么？" class="headerlink" title="这段代码里的 this 是什么？"></a>这段代码里的 this 是什么？</h3><ol>
<li>fn() 里面的 this 就是 window</li>
<li>fn() 是 strict mode(严格模式)，this 就是 undefined</li>
<li>a.b.c.fn() 里面的 this 就是 a.b.c</li>
<li>new F() 里面的 this 就是新生成的实例</li>
<li>() =&gt; console.log(this) 里面 this 跟外面的 this 的值一模一样，永远取它上级作用域的this</li>
</ol>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/23804247">知乎 - this 的值到底是什么？一次说清楚</a></p>
<h3 id="什么是立即执行函数？使用立即执行函数的目的是什么？"><a href="#什么是立即执行函数？使用立即执行函数的目的是什么？" class="headerlink" title="什么是立即执行函数？使用立即执行函数的目的是什么？"></a>什么是立即执行函数？使用立即执行函数的目的是什么？</h3><h3 id="async-await-语法了解吗？目的是什么？"><a href="#async-await-语法了解吗？目的是什么？" class="headerlink" title="async/await 语法了解吗？目的是什么？"></a>async/await 语法了解吗？目的是什么？</h3><h3 id="如何实现数组去重？"><a href="#如何实现数组去重？" class="headerlink" title="如何实现数组去重？"></a>如何实现数组去重？</h3><h3 id="观察者模式-vs-发布-订阅模式"><a href="#观察者模式-vs-发布-订阅模式" class="headerlink" title="观察者模式 vs 发布-订阅模式"></a>观察者模式 vs 发布-订阅模式</h3><p><a href="https://juejin.im/post/5a14e9edf265da4312808d86">观察者模式 vs 发布-订阅模式</a></p>
<h3 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h3><p><a href="https://juejin.im/post/5e75e22951882549027687f9">JS继承</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="comment">//构造继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, ...arguments)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"><span class="comment">//寄生组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My grade is "</span> + <span class="keyword">this</span>.grade + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型式继承</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent)</span><br><span class="line"><span class="comment">//寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(orginal)</span><br><span class="line">  clone.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//混入方式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  OtherParent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line"><span class="built_in">Object</span>.assign(Child.prototype, OtherParent.prototype)</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure></p>
<h3 id="CSRF-XSS"><a href="#CSRF-XSS" class="headerlink" title="CSRF XSS"></a>CSRF XSS</h3><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF（Cross-site request forgery）跨站请求伪造。</p>
<h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；<br>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；<br>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；<br>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行</p>
<h5 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h5><ul>
<li>验证 HTTP Referer 字段；Referer 来判断该请求是否为第三方网站发起的</li>
<li>在请求地址中添加 token 并验证；由服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效</li>
<li>在 HTTP 头中自定义属性并验证；可以对 Cookie 设置 SameSite 属性，该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击</li>
</ul>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS（cross-site scripting）跨域脚本攻击</p>
<h5 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h5><p><strong>存储型</strong>：<br>1.攻击者将恶意代码提交到目标网站的数据库中<br>2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p>
<p><strong>反射型</strong>：<br>1.攻击者构造出特殊的 URL，其中包含恶意代码<br>2.用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p>
<p><strong>DOM型</strong>：<br>1.攻击者构造出特殊的 URL，其中包含恶意代码<br>2.用户打开带有恶意代码的 URL<br>3.用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</p>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p>
<h5 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h5><ul>
<li>HTML：对以下敏感字符进行转义：&amp;  &lt;  &gt; ‘ “ /</li>
<li>Javascript：把所有非字母、数字的字符都转义成小于256的ASCII字符</li>
<li>URL：使用Javascript的encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：,  /  ?  :  @  &amp;  =  +  $  #</li>
<li>设置httpOnly</li>
<li>开启CSP，即开启白名单，可阻止白名单以外的资源加载和运行</li>
</ul>
<h3 id="请用一句话描述-try-catch-能捕获到哪些-JS-异常"><a href="#请用一句话描述-try-catch-能捕获到哪些-JS-异常" class="headerlink" title="请用一句话描述 try catch 能捕获到哪些 JS 异常"></a>请用一句话描述 try catch 能捕获到哪些 JS 异常</h3><p>能被 try catch 捕捉到的异常，必须是在报错的时候，线程执行已经进入 try catch 代码块，且处在 try catch 里面，这个时候才能被捕捉到<br><a href="https://juejin.im/post/5ea8e2d65188256d8d605b2d">try catch能捕获到哪些JS异常</a></p>
<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><h4 id="DOM事件的具体捕获流程"><a href="#DOM事件的具体捕获流程" class="headerlink" title="DOM事件的具体捕获流程"></a>DOM事件的具体捕获流程</h4><p>捕获的流程为：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素<br>冒泡的流程为：目标元素-&gt; … -&gt; body -&gt; html -&gt; document -&gt; window</p>
<h4 id="event对象常见使用"><a href="#event对象常见使用" class="headerlink" title="event对象常见使用"></a>event对象常见使用</h4><p>1.event.preventDefault()<br>取消事件的默认动作<br>2.event.stopPropagation()<br>阻止事件冒泡<br>3.event.stopImmediatePropagation()<br>阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他的两个事件将不会被执行</p>
<h4 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h4><p>true表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件<br>false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</p>
<h3 id="前端跨域"><a href="#前端跨域" class="headerlink" title="前端跨域"></a>前端跨域</h3><p><a href="https://segmentfault.com/a/1190000011145364">前端跨域</a></p>
<h3 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h3><p>1.资源压缩合并，减少 HTTP 请求<br>2.非核心代码异步加载（异步加载的方式，异步加载的区别）<br>3.利用浏览器缓存（缓存的分类，缓存原理）<br>4.使用 CDN<br>5.预解析 DNS<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//强制打开 <span class="tag">&lt;<span class="name">a</span>&gt;</span> 标签的 dns 解析</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-controller"</span> <span class="attr">content</span>=<span class="string">"on"</span>&gt;</span></span><br><span class="line">//DNS预解析</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//host_name_to_prefetch.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h4><p>异步加载的方式：1.动态脚本加载 2.defer 3.async<br>异步加载的区别：<br>1.defer 浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。defer脚本会在 <code>DOMContentLoaded</code> 和 <code>load</code> 事件之前执行<br>2.async 同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于script有先后依赖关系的情况，并不适用。async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序</p>
<p><img src="/images/171d353539501527.webp"></p>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</strong>也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。<br><strong>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</strong><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。<br><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。<br><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。<br><strong>s-maxage</strong>：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</p>
<h5 id="Expires和Cache-Control两者对比"><a href="#Expires和Cache-Control两者对比" class="headerlink" title="Expires和Cache-Control两者对比"></a>Expires和Cache-Control两者对比</h5><p>其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，<strong>两者同时存在的话，Cache-Control优先级高于Expires</strong>；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<ul>
<li>协商缓存生效，返回304和Not Modified</li>
<li>协商缓存失效，返回200和请求结果</li>
</ul>
<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>
<h5 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h5><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified 的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code>；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。</p>
<p>if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。</p>
<ul>
<li>如果没有被修改：则开始`继续’传送文件，服务器返回: 200 OK</li>
<li>如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误)</li>
</ul>
<p><strong>但是 Last-Modified 存在一些弊端：</strong></p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li>
<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>
</ul>
<p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match</p>
<h5 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h5><p><strong>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</strong>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<h5 id="Last-Modified和ETag两者对比"><a href="#Last-Modified和ETag两者对比" class="headerlink" title="Last-Modified和ETag两者对比"></a>Last-Modified和ETag两者对比</h5><ul>
<li>首先在精确度上，Etag要优于Last-Modified。<br>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li>
<li>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li>
<li>第三在优先级上，服务器校验优先考虑Etag</li>
</ul>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p>
<h4 id="缓存场景"><a href="#缓存场景" class="headerlink" title="缓存场景"></a>缓存场景</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>
<ul>
<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>
<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新</li>
<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li>
</ul>
<h3 id="如何解决a标点击后hover事件失效"><a href="#如何解决a标点击后hover事件失效" class="headerlink" title="如何解决a标点击后hover事件失效"></a>如何解决a标点击后hover事件失效</h3><p>只需要记住<code>LoVe HAte</code>原则就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link→visited→hover→active</span><br></pre></td></tr></table></figure></p>
<h3 id="CommonJS和ES6模块的区别"><a href="#CommonJS和ES6模块的区别" class="headerlink" title="CommonJS和ES6模块的区别"></a>CommonJS和ES6模块的区别</h3><ul>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
<li>CommonJS 模块输出的是一个值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；ES6 模块输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li>
<li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li>
<li>CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li>
<li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li>
</ul>
<p>(前端模块化：CommonJS,AMD,CMD,ES6)[<a href="https://juejin.im/post/5aaa37c8f265da23945f365c]">https://juejin.im/post/5aaa37c8f265da23945f365c]</a></p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>相对于HTTP1.1，HTTP2的优化：</p>
<ul>
<li>HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送</li>
<li>HTTP2支持多路复用（一次 TCP 连接可以处理多个请求）</li>
<li>HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积</li>
<li>HTTP2支持服务端推送</li>
</ul>
<p>HTTP 与 HTTPS 的区别</p>
<ul>
<li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li>
<li>HTTP 的端口号是 80，HTTPS 是 443</li>
<li>HTTPS 需要到 CA 申请证书</li>
<li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</li>
</ul>
<p>HTTPS：HTTP + TLS（ 非对称加密 与 对称加密 ）</p>
<ul>
<li>客户端发出 https 请求，请求服务端建立 SSL 连接</li>
<li>服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端</li>
<li>客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥</li>
<li>客户端将公钥与客户端私钥进行非对称加密后传给服务端</li>
<li>服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥</li>
<li>服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端</li>
<li>客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容</li>
</ul>
<p>(HTTPS面试问答)[<a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.md]">https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.md]</a><br>(一个故事讲完https)[<a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA]">https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA]</a></p>
<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><p>TCP/IP协议族按层次分别分为以下四层：应用层、传输层、网络层和数据链路层，TCP和UDP是指传输层两个性质不同的协议。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p>
<ul>
<li>基于流的方式</li>
<li>面向连接</li>
<li>丢包重传</li>
<li>保证数据顺序</li>
<li>确保数据能到达目标</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。</p>
<ul>
<li>UDP 是非连接的协议，也就是不会跟终端建立连接</li>
<li>UDP 包信息只有 8 个字节</li>
<li>UDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界</li>
<li>UDP 可能丢包</li>
<li>UDP 不保证数据顺序</li>
</ul>
<h3 id="TCP-三次握手-四次挥手"><a href="#TCP-三次握手-四次挥手" class="headerlink" title="TCP 三次握手 四次挥手"></a>TCP 三次握手 四次挥手</h3><p>三次握手:</p>
<ul>
<li>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li>
<li>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li>
<li>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</li>
</ul>
<p>四次挥手:</p>
<ul>
<li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送，客户端进入FIN-WAIT-1</li>
<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号，服务端进入CLOSED-WAIT，客户端收到ACK后进入FIN-WAIT-2</li>
<li>服务器关闭客户端的连接，发送一个FIN给客户端，进入LAST-ACK阶段，收到客户端ACK报文后进入CLOSED</li>
<li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1，客户端进入TIME-WAIT，等待2MSL后进入CLOSED</li>
</ul>
<h3 id="如何避免重排和重绘"><a href="#如何避免重排和重绘" class="headerlink" title="如何避免重排和重绘"></a>如何避免重排和重绘</h3><p>CSS：</p>
<ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上</li>
<li>避免使用CSS表达式（例如：calc()）</li>
<li>CSS3硬件加速（GPU加速）</li>
</ul>
<p>JavaScript：</p>
<ul>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</li>
</ul>
<h3 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h3><p>JavaScript的运行机制:<br>1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>2.主线程之外，还存在”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>3.一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>4.主线程不断重复上面的第三步</p>
<p>概括即是: 调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作</p>
<p>JavaScript中有两种异步任务:</p>
<ul>
<li>宏任务： script （主代码块）、<code>setTimeout</code> 、<code>setInterval</code> 、<code>setImmediate</code> 、I/O 、UI rendering</li>
<li>微任务：<code>process.nextTick</code>（Nodejs） 、<code>Promise</code> 、<code>Object.observe</code> 、<code>MutationObserver</code></li>
</ul>
<p><strong>事件循环(event-loop)是什么？</strong></p>
<p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行。</p>
<p>详细说明：</p>
<ul>
<li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会跳转至microtask的执行步骤。</li>
<li>将事件循环的当前运行宏任务设置为已选择的宏任务。</li>
<li>运行宏任务。</li>
<li>将事件循环的当前运行任务设置为null。</li>
<li>将运行完的宏任务从宏任务队列中移除。</li>
<li>microtasks步骤：进入microtask检查点。</li>
<li>更新界面渲染。</li>
<li>返回第一步。</li>
</ul>
<h3 id="Node的Event-Loop"><a href="#Node的Event-Loop" class="headerlink" title="Node的Event Loop"></a>Node的Event Loop</h3><ul>
<li>timers: 执行setTimeout和setInterval中到期的callback。</li>
<li>pending callback: 上一轮循环中少数的callback会放在这一阶段执行。</li>
<li>idle, prepare: 仅在内部使用。</li>
<li>poll: 最重要的阶段，执行pending callback，在适当的情况下回阻塞在这个阶段。</li>
<li>check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。</li>
<li>close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。</li>
</ul>
<h3 id="说一说从输入URL到页面呈现发生了什么"><a href="#说一说从输入URL到页面呈现发生了什么" class="headerlink" title="说一说从输入URL到页面呈现发生了什么"></a>说一说从输入URL到页面呈现发生了什么</h3><p>1.在浏览器地址栏内按下第一个键后浏览器会调用自己的算法，去书签栏或者历史记录中将我们可能访问的URL显示出来</p>
<p>2.点击要访问的URL后，浏览器会先检测URL是否合法，如果没问题会调用网络线程来准备发送网络请求</p>
<p>3.先在HTTP应用层内构建请求行，但不会发送网络请求，会先在强缓存中查找强缓存是否有效</p>
<p>4.强缓存无效的话，就会调用DNS域名解析将URL解析成IP地址</p>
<p>5.此时进入TCP传输层，进行TCP三次握手，握手完毕后将请求报文分割并打上标记生成数据包，将处理后的数据包转发给网络层</p>
<p>6.网络层拿到数据包后，调用ARP协议，通过IP地址反查出MAC地址</p>
<p>7.拿到IP地址、MAC地址、数据包后，在数据链路层内发起请求</p>
<p>8.服务端收到请求后，一层层的将报文剥开，其中就会把在传输层分割的报文组装起来，接着对请求会进行校验，比如是否有缓存字段、请求是否有权限。如果缓存有效，那么就会返回304状态码提醒浏览器使用缓存，这里其实就是协商缓存的步骤</p>
<p>9.如果缓存过期或者没设置，那么服务端就会返回请求的文件，如HTML、CSS和JS文件，浏览器接收到文件后，服务器会检测报文中的Connection的值是否等于keepw-alive，如果不是keep-alive就会断开链接，但在HTTP 1.1协议后，Connection默认为keep-alive</p>
<p>10.浏览器接收到HTML文件后就会进行处理，这个过程是交给渲染引擎的GUI线程来做，根据HTML文件中定义的charset和doctype来解析文档，GUI线程调用标记化算法和建树算法，实际上就是词法分析和语法分析，生成以document为根节点的DOM树</p>
<p>11.CSS的解析也是同理，只不过会先将CSS文件格式化成styleSheet对象，然后标准化这个对象，比如color: red这个属性会被格式化成16进制的数，最后将计算的结果挂载到window.getStyleComputed上，我们可以通过JS代码访问，但会引起回流</p>
<p>12.CSS解析和HTML解析互不干扰，但JS文件就会造成阻塞，因为渲染引擎中的JS线程和GUI线程是互斥的，且JS引擎的优先级比GUI线程高，会将GUI线程挂起，所以script会阻塞页面解析，要放在底部，而link CSS在头部</p>
<p>13.在拿到CSSOM树和DOM树后，会将二者合成为布局树，精确的计算出每一个节点所处的位置以及样式</p>
<p>14.浏览器在渲染前会进行图层处理，图层分为普通图层和复杂图层，而普通文档流内所有的元素所处的就是一个复杂图层，每个复杂图层都会被GPU单独绘制，所以它们之间的重绘不会影响其他图层，提成为复杂图层的方式有：</p>
<ul>
<li>1.拥有层叠上下文的特点，如scroll</li>
<li>2.设置z-index</li>
</ul>
<p>但要注意设置z-index的元素如果本身层叠上下文的等级就比较低，会引起层爆炸，在它上面的图层都会被提升成复杂图层，页面可能会崩溃</p>
<p>15.将绘制指令传入渲染队列中，通过合成线程生成图块和位图，开始渲染页面，所以常说要尽量使用opacity transform等属性，因为它们会调用GPU单独绘制，也就是所谓的硬件加速</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程：资源分配的最小单位</p>
<p>线程：资源调度的最小单位</p>
<h3 id="首屏加载优化有哪些方案"><a href="#首屏加载优化有哪些方案" class="headerlink" title="首屏加载优化有哪些方案"></a>首屏加载优化有哪些方案</h3><ul>
<li>Vue-Router路由懒加载（利用Webpack的代码切割）</li>
<li>使用CDN加速，将通用的库从vendor进行抽离</li>
<li>Nginx的gzip压缩</li>
<li>Vue异步组件</li>
<li>服务端渲染SSR</li>
<li>如果使用了一些UI库，采用按需加载</li>
<li>Webpack开启gzip压缩</li>
<li>如果首屏为登录页，可以做成多入口</li>
<li>Service Worker缓存文件处理</li>
<li>使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li>
</ul>
<h3 id="谈谈你对作用域链的理解"><a href="#谈谈你对作用域链的理解" class="headerlink" title="谈谈你对作用域链的理解"></a>谈谈你对作用域链的理解</h3><p>了解作用域链之前我们要知道一下几个概念：</p>
<ul>
<li>函数的生命周期</li>
<li>变量和函数的声明</li>
<li>Activetion Object（AO）、Variable Object（VO）</li>
</ul>
<p>函数的生命周期：</p>
<ul>
<li>创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。</li>
<li>执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。</li>
</ul>
<p>变量和函数的声明：如果变量名和函数名声明时相同，函数优先声明。</p>
<p>Activetion Object（AO）、Variable Object（VO）：</p>
<ul>
<li>AO：Activetion Object（活动对象）</li>
<li>VO：Variable Object（变量对象）</li>
</ul>
<p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p>
<ul>
<li>变量 (var, 变量声明);</li>
<li>函数声明 (FunctionDeclaration, 缩写为FD);</li>
<li>函数的形参</li>
</ul>
<p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p>
<ul>
<li>函数的所有局部变量</li>
<li>函数的所有命名参数</li>
<li>函数的参数集合</li>
<li>函数的this指向</li>
</ul>
<p>作用域链：</p>
<p>当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。<br>在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：<strong>有没有创建一个文档树之外的元素。</strong><br>CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>容器的属性: </p>
<ul>
<li>flex-direction 属性决定主轴的方向（即项目的排列方向）。</li>
<li>flex-wrap 属性定义，如果一条轴线排不下，如何换行</li>
<li>flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>
<li>justify-content 属性定义了项目在主轴上的对齐方式。</li>
<li>align-items 属性定义项目在交叉轴上如何对齐</li>
<li>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<p>项目的属性:</p>
<ul>
<li>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>
<li>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</li>
</ul>
<h3 id="简单介绍一下-V8-引擎的垃圾回收机制"><a href="#简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="简单介绍一下 V8 引擎的垃圾回收机制"></a>简单介绍一下 V8 引擎的垃圾回收机制</h3><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p>
<p>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</p>
<p>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</p>
<p>（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</p>
<p>（2）如果对象不存活，则释放对象的空间。</p>
<p>（3）最后将 From 空间和 To 空间角色进行交换。</p>
<p>新生代对象晋升到老生代有两个条件：</p>
<p>（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</p>
<p>（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</p>
<p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p>
<p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p>
<h3 id="JS自定义事件"><a href="#JS自定义事件" class="headerlink" title="JS自定义事件"></a>JS自定义事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建事件对象：</span></span><br><span class="line"><span class="keyword">let</span> ev = <span class="built_in">document</span>.createEvent(<span class="string">'CustomEvent'</span>)</span><br><span class="line"><span class="comment">//初始化事件对象：事件的类型名称/一个布尔值,表明该事件是否会冒泡/一个布尔值,表明该事件是否可以被取消/当事件初始化时传递的数据</span></span><br><span class="line">ev.initCustomEvent(<span class="string">'ev'</span>, <span class="literal">false</span>, <span class="literal">true</span>, &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">//监听事件：</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'ev'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(e.detail.b) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.dispatchEvent(ev)</span><br></pre></td></tr></table></figure>
<h3 id="ES6-symbol理解及使用场景"><a href="#ES6-symbol理解及使用场景" class="headerlink" title="ES6 symbol理解及使用场景"></a>ES6 symbol理解及使用场景</h3><p>1: 使用Symbol来作为对象属性名(key)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'name'</span>)]: <span class="string">'pan'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  title: <span class="string">'Engineer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)   <span class="comment">// ['age', 'title']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(p)   <span class="comment">// 分别会输出：'age' 和 'title'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)   <span class="comment">// ['age', 'title']</span></span><br></pre></td></tr></table></figure><br>Symbol类型的key是不能通过<code>Object.keys()</code>或者<code>for...in</code>来枚举的，所以利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(obj)  <span class="comment">// &#123;"age":27,"title":"Engineer"&#125;</span></span><br></pre></td></tr></table></figure>
<p>当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外,<br>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p>
<p>可以通过特定的Api获取Symbol定义的对象属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Object的API</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新增的反射API</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// [Symbol(name), 'age', 'title']</span></span><br></pre></td></tr></table></figure></p>
<p>2: 使用Symbol来替代常量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="string">'AUDIO'</span></span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="string">'VIDEO'</span></span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="string">'IMAGE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了Symbol，直接定义就保证了三个常量的值是唯一的</span></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure></p>
<p>3: 使用Symbol定义类的私有属性/方法</p>
<ul>
<li><p>在a.js中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PASSWORD = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(username, password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPassword(pwd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br></pre></td></tr></table></figure>
</li>
<li><p>在b.js中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> Login(<span class="string">'admin'</span>, <span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line">login.checkPassword(<span class="string">'123456'</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">login.PASSWORD  <span class="comment">// oh!no!</span></span><br><span class="line">login[PASSWORD] <span class="comment">// oh!no!</span></span><br><span class="line">login[<span class="string">"PASSWORD"</span>] <span class="comment">// oh!no!</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个PASSWORD的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p>
<p>4: 注册和获取全局Symbol<br><code>Symbol.for()</code>它可以注册或获取一个window间全局的Symbol实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gs1 = <span class="built_in">Symbol</span>.for(<span class="string">'global_symbol_1'</span>)  <span class="comment">//注册一个全局Symbol</span></span><br><span class="line"><span class="keyword">let</span> gs2 = <span class="built_in">Symbol</span>.for(<span class="string">'global_symbol_1'</span>)  <span class="comment">//获取全局Symbol</span></span><br><span class="line"></span><br><span class="line">gs1 === gs2  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<p>参考：<br><a href="https://juejin.im/post/5eace2176fb9a04340658974">前端面试必备技巧</a><br><a href="https://www.cxymsg.com/">前端面试与进阶指南</a></p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JaveScript/">JaveScript</a><a class="link-muted mr-2" rel="tag" href="/tags/HTML/">HTML</a><a class="link-muted mr-2" rel="tag" href="/tags/CSS/">CSS</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5e940d899d6bcc0012d5bba2&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/01/16/git/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Git</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/08/21/frontInterview2/"><span class="level-item">前端面试题（手写）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: undefined,
            verify: undefined,
            appId: 'MDfbshkmK8Hdwft8ef04sbH2-gzGzoHsz',
            appKey: 'Ow46GmTfAGgQhisz2k29kK3M',
            placeholder: 'undefined',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/avatar.png" alt="Panson"></figure><p class="title is-size-4 is-block line-height-inherit">Panson</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#HTML"><span class="mr-2">1</span><span>HTML</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#你是如何理解-HTML-语义化的？"><span class="mr-2">1.1.1</span><span>你是如何理解 HTML 语义化的？</span></a></li><li><a class="is-flex" href="#说说盒模型"><span class="mr-2">1.1.2</span><span>说说盒模型</span></a></li><li><a class="is-flex" href="#css-reset-和-normalize-css-有什么区别？"><span class="mr-2">1.1.3</span><span>css reset 和 normalize.css 有什么区别？</span></a></li><li><a class="is-flex" href="#如何居中？"><span class="mr-2">1.1.4</span><span>如何居中？</span></a></li><li><a class="is-flex" href="#选择器优先级如何确定？"><span class="mr-2">1.1.5</span><span>选择器优先级如何确定？</span></a></li><li><a class="is-flex" href="#BFC-是什么？"><span class="mr-2">1.1.6</span><span>BFC 是什么？</span></a></li><li><a class="is-flex" href="#如何清除浮动？"><span class="mr-2">1.1.7</span><span>如何清除浮动？</span></a></li><li><a class="is-flex" href="#JS-有哪些数据类型？"><span class="mr-2">1.1.8</span><span>JS 有哪些数据类型？</span></a></li><li><a class="is-flex" href="#Promise-怎么使用？"><span class="mr-2">1.1.9</span><span>Promise 怎么使用？</span></a></li><li><a class="is-flex" href="#手写原生AJAX"><span class="mr-2">1.1.10</span><span>手写原生AJAX</span></a></li><li><a class="is-flex" href="#闭包是什么？"><span class="mr-2">1.1.11</span><span>闭包是什么？</span></a></li><li><a class="is-flex" href="#这段代码里的-this-是什么？"><span class="mr-2">1.1.12</span><span>这段代码里的 this 是什么？</span></a></li><li><a class="is-flex" href="#什么是立即执行函数？使用立即执行函数的目的是什么？"><span class="mr-2">1.1.13</span><span>什么是立即执行函数？使用立即执行函数的目的是什么？</span></a></li><li><a class="is-flex" href="#async-await-语法了解吗？目的是什么？"><span class="mr-2">1.1.14</span><span>async/await 语法了解吗？目的是什么？</span></a></li><li><a class="is-flex" href="#如何实现数组去重？"><span class="mr-2">1.1.15</span><span>如何实现数组去重？</span></a></li><li><a class="is-flex" href="#观察者模式-vs-发布-订阅模式"><span class="mr-2">1.1.16</span><span>观察者模式 vs 发布-订阅模式</span></a></li><li><a class="is-flex" href="#JS继承"><span class="mr-2">1.1.17</span><span>JS继承</span></a></li><li><a class="is-flex" href="#预防措施"><span class="mr-2">1.1.18</span><span>预防措施</span></a></li><li><a class="is-flex" href="#预防措施-1"><span class="mr-2">1.1.19</span><span>预防措施</span></a></li><li><a class="is-flex" href="#请用一句话描述-try-catch-能捕获到哪些-JS-异常"><span class="mr-2">1.1.20</span><span>请用一句话描述 try catch 能捕获到哪些 JS 异常</span></a></li><li><a class="is-flex" href="#addEventListener的第三个参数"><span class="mr-2">1.1.21</span><span>addEventListener的第三个参数</span></a></li><li><a class="is-flex" href="#前端跨域"><span class="mr-2">1.1.22</span><span>前端跨域</span></a></li><li><a class="is-flex" href="#缓存场景"><span class="mr-2">1.1.23</span><span>缓存场景</span></a></li><li><a class="is-flex" href="#如何解决a标点击后hover事件失效"><span class="mr-2">1.1.24</span><span>如何解决a标点击后hover事件失效</span></a></li><li><a class="is-flex" href="#CommonJS和ES6模块的区别"><span class="mr-2">1.1.25</span><span>CommonJS和ES6模块的区别</span></a></li><li><a class="is-flex" href="#HTTPS"><span class="mr-2">1.1.26</span><span>HTTPS</span></a></li><li><a class="is-flex" href="#UDP"><span class="mr-2">1.1.27</span><span>UDP</span></a></li><li><a class="is-flex" href="#TCP-三次握手-四次挥手"><span class="mr-2">1.1.28</span><span>TCP 三次握手 四次挥手</span></a></li><li><a class="is-flex" href="#如何避免重排和重绘"><span class="mr-2">1.1.29</span><span>如何避免重排和重绘</span></a></li><li><a class="is-flex" href="#浏览器的Event-Loop"><span class="mr-2">1.1.30</span><span>浏览器的Event Loop</span></a></li><li><a class="is-flex" href="#Node的Event-Loop"><span class="mr-2">1.1.31</span><span>Node的Event Loop</span></a></li><li><a class="is-flex" href="#说一说从输入URL到页面呈现发生了什么"><span class="mr-2">1.1.32</span><span>说一说从输入URL到页面呈现发生了什么</span></a></li><li><a class="is-flex" href="#进程和线程的区别"><span class="mr-2">1.1.33</span><span>进程和线程的区别</span></a></li><li><a class="is-flex" href="#首屏加载优化有哪些方案"><span class="mr-2">1.1.34</span><span>首屏加载优化有哪些方案</span></a></li><li><a class="is-flex" href="#谈谈你对作用域链的理解"><span class="mr-2">1.1.35</span><span>谈谈你对作用域链的理解</span></a></li><li><a class="is-flex" href="#伪类和伪元素的区别"><span class="mr-2">1.1.36</span><span>伪类和伪元素的区别</span></a></li><li><a class="is-flex" href="#flex"><span class="mr-2">1.1.37</span><span>flex</span></a></li><li><a class="is-flex" href="#简单介绍一下-V8-引擎的垃圾回收机制"><span class="mr-2">1.1.38</span><span>简单介绍一下 V8 引擎的垃圾回收机制</span></a></li><li><a class="is-flex" href="#JS自定义事件"><span class="mr-2">1.1.39</span><span>JS自定义事件</span></a></li><li><a class="is-flex" href="#ES6-symbol理解及使用场景"><span class="mr-2">1.1.40</span><span>ES6 symbol理解及使用场景</span></a></li></ul></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://www.destinesia.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Destinesia</span></span><span class="level-right"><span class="level-item tag">www.destinesia.cn</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"><span class="level-start"><span class="level-item">原创文章</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-08T07:15:16.000Z">2020-07-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/08/note/">note</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-12T05:46:09.000Z">2020-06-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/12/webpack/">webpack</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-12T03:34:36.000Z">2020-06-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/12/vue3/">Vue3</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-12T10:54:14.000Z">2020-05-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/12/designPatterns/">设计模式</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-26T06:47:51.000Z">2020-04-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/26/vue/">Vue</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JaveScript/"><span class="tag">JaveScript</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag is-grey-lightest">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Panson的个人网站" height="28"></a><p class="size-small"><span>&copy; 2021 Panson</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://panpanson.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>