<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Panson的个人网站</title><meta description="panson的技术博客，从设计到前端，正在学习python，立志打通设计到前端到服务端的障碍"><meta property="og:type" content="blog"><meta property="og:title" content="Panson的个人网站"><meta property="og:url" content="https://panpanson.github.io/"><meta property="og:site_name" content="Panson的个人网站"><meta property="og:description" content="panson的技术博客，从设计到前端，正在学习python，立志打通设计到前端到服务端的障碍"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://panpanson.github.io/img/og_image.png"><meta property="article:author" content="Panson"><meta property="article:tag" content="前端，python，hexo，接项目，外包"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://panpanson.github.io"},"headline":"Panson的个人网站","image":["https://panpanson.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Panson"},"description":"panson的技术博客，从设计到前端，正在学习python，立志打通设计到前端到服务端的障碍"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/font-awesome/5.12.0/css/fontawesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Panson的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-09T09:19:58.000Z" title="2020-07-09T09:19:58.000Z">2020-07-09</time><span class="level-item">6 分钟 读完 (大约 965 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/09/node/">NodeJs</a></h1><div class="content"><a id="more"></a>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>基础概念：</p>
<ul>
<li>进程：进程（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。</li>
<li>线程：线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</li>
<li>协程：协程（英语：coroutine），又称微线程，是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。<br>Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的，各个线程如下：</li>
<li>主线程：编译、执行代码。</li>
<li>编译/优化线程：在主线程执行的时候，可以优化代码。</li>
<li>分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。</li>
<li>垃圾回收的几个线程。</li>
</ul>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>注意：每个框被称为事件循环机制的一个阶段。</p>
<p>阶段概述：</p>
<ul>
<li>定时器 ：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。</li>
<li>待定回调 ：执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare ：仅系统内部使用。</li>
<li>轮询 ：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li>
<li>检测 ：setImmediate() 回调函数在这里执行。</li>
<li>关闭的回调函数 ：一些关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ul>
<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-08T07:15:16.000Z" title="2020-07-08T07:15:16.000Z">2020-07-08</time><span class="level-item">几秒 读完 (大约 93 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/08/note/">note</a></h1><div class="content"><a id="more"></a>
<p>1.offsetleft offsettop<br>3.输入url到页面展示 发生了什么<br>4.返回字符串的最长不重复子串长度<br>5.flex 1 = flex grow 1  flex shrink 1  flex basic 0%<br>6.浏览器渲染也页面过程<br>7.手写 bind、reduce<br>8.webpack 的 require 是如何查找依赖的<br>9.webpack 如何实现动态加载<br>10.cookie新属性<br>11.dillPlugin<br>12.TCP/IP<br>13.css3三角形<br>14.vue不能监听数组变化</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-12T05:46:09.000Z" title="2020-06-12T05:46:09.000Z">2020-06-12</time><span class="level-item">7 分钟 读完 (大约 1104 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/12/webpack/">webpack</a></h1><div class="content"><a id="more"></a>
<h3 id="webpack如何打包优化"><a href="#webpack如何打包优化" class="headerlink" title="webpack如何打包优化"></a>webpack如何打包优化</h3><p>先使用webpack-bundle-analyzer分析打包后整个项目中的体积结构，既可以看到项目中用到的所有第三方包，又能看到各个模块在整个项目中的占比。</p>
<p>1.按需加载<br>1.1 路由按需加载<br>Vue中路由懒加载，使用<code>() =&gt; import(xxx.vue)</code>形式，打包会根据路由自动拆分打包。<br>1.2 第三方库按需加载<br>尽量按需加载，避免把整个库打包到项目中去。</p>
<p>2.文件解析优化<br>loader解析优化：通过配置<code>include</code>和<code>exclude</code>来减少被处理的文件，还可以配合<code>cacheDirectory</code>来缓存编译后的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader?cacheDirectory'</span>,</span><br><span class="line">      include: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">      ],</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文件解析优化：通过配置<code>resolve</code>选项中的<code>alias</code>、<code>extensions</code>、<code>modules</code>来实现。<br>alias：创建import或require的别名，加快webpack查找速度。<br>extensions：自动解析确定的扩展，默认值为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [<span class="string">".js"</span>, <span class="string">".json"</span>]</span><br></pre></td></tr></table></figure><br>modules：解析模块时应该搜索的目录，通常建议使用绝对路径，避免层层查找祖先目录。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">"src"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  extensions: [<span class="string">".js"</span>, <span class="string">".vue"</span>],</span><br><span class="line">  mainFields: [<span class="string">"index"</span>, <span class="string">"main"</span>],</span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">"src"</span>),<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.拆分公共模块<br>使用splitChunks进行拆包，抽离公共模块。<br>splitChunks默认配置如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">    <span class="comment">// 表示选择哪些 chunks 进行分割，可选值有：async(按需加载)，initial(直接引用)和all</span></span><br><span class="line">    chunks: <span class="string">"async"</span>,</span><br><span class="line">    <span class="comment">// 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。</span></span><br><span class="line">    minSize: <span class="number">30000</span>,</span><br><span class="line">    <span class="comment">// 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。</span></span><br><span class="line">    minChunks: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 表示按需加载文件时，并行请求的最大数目。默认为5。</span></span><br><span class="line">    maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">    <span class="comment">// 表示加载入口文件时，并行请求的最大数目。默认为3。</span></span><br><span class="line">    maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js</span></span><br><span class="line">    automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">    <span class="comment">// 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。</span></span><br><span class="line">    name: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。</span></span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">            test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">            priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">            minChunks: <span class="number">2</span>,</span><br><span class="line">            priority: <span class="number">-20</span>,</span><br><span class="line">            reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结下来就是：</p>
<ul>
<li>被复用代码或者来自<code>node_moules</code>文件夹中的模块</li>
<li>模块的体积大小必须大于等于30kb才进行拆分</li>
<li>当按需加载chunks时，并行请求的最大数量不能超过5</li>
<li>初始页面加载时，并行请求的最大数量不能超过3</li>
</ul>
<p>下面就是把node_modules中的react和moment再进行拆分，避免打包出的vendor包过大。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;  </span><br><span class="line">  chunks: <span class="string">'all'</span>,  </span><br><span class="line">  minSize: <span class="number">30000</span>,</span><br><span class="line">  minChunks: <span class="number">1</span>,</span><br><span class="line">  cacheGroups: &#123;    </span><br><span class="line">    lib: &#123;      </span><br><span class="line">      name: <span class="string">'vendors'</span>,      </span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,      </span><br><span class="line">      priority: <span class="number">10</span>,      </span><br><span class="line">      chunks: <span class="string">'initial'</span> <span class="comment">// 只打包初始时依赖的第三方    </span></span><br><span class="line">    &#125;,    </span><br><span class="line">    react: &#123;      </span><br><span class="line">      name: <span class="string">'react'</span>, <span class="comment">// 单独将 react 拆包      </span></span><br><span class="line">      priority: <span class="number">20</span>,</span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]react[\\/]/</span>,      </span><br><span class="line">      chunks: <span class="string">'all'</span>    </span><br><span class="line">    &#125;,</span><br><span class="line">    moment: &#123;</span><br><span class="line">      name: <span class="string">'moment'</span>, <span class="comment">//单独将moment拆包</span></span><br><span class="line">      priority: <span class="number">20</span>,</span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]moment[\\/]/</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">      priority: <span class="number">-20</span>,</span><br><span class="line">      reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.DllPlugin和DllReferencePlugin<br>通常打包过程中，由于第三方库代码不经常改变，我们可以将第三方库的代码跟业务代码抽离。DllPlugin 和 DLLReferencePlugin 可以实现拆分 bundles，并且可以大大提升构建速度，DllPlugin 和 DLLReferencePlugin 都是 webpack 的内置模块。</p>
<p>配置webpack.dll.js，将lodash、jquery、antd抽离出来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    lodash: [<span class="string">"lodash"</span>],</span><br><span class="line">    jquery: [<span class="string">"jquery"</span>],</span><br><span class="line">    antd: [<span class="string">"antd"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].dll.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dll"</span>),</span><br><span class="line">    library: <span class="string">"[name]"</span> <span class="comment">// name和library保持一致</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">"[name]"</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"manifest/[name].manifest.json"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>配置package.json中，新增script打包dll<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  ...,</span><br><span class="line">  &quot;dll&quot;: &quot;webpack --config webpack.dll.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行npm run dll，生成dll文件和对应的manifest.json。</p>
<p>将打包的dll通过add-asset-html-webpack-plugin添加到html中，再通过DllReferencePlugin把dll引用到需要编译的依赖。</p>
<p>配置<code>webpack.config.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> manifests = [<span class="string">'antd'</span>, <span class="string">'jquery'</span>, <span class="string">'lodash'</span>];</span><br><span class="line"><span class="keyword">const</span> dllPlugins = manifests.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: <span class="built_in">require</span>(<span class="string">`./manifest/<span class="subst">$&#123;item&#125;</span>.manifest`</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...dllPlugins,</span><br><span class="line">    <span class="keyword">new</span> AddAssetHtmlPlugin(&#123;</span><br><span class="line">      filepath: path.resolve(__dirname, <span class="string">"./dll/*.dll.js"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-12T03:34:36.000Z" title="2020-06-12T03:34:36.000Z">2020-06-12</time><span class="level-item">几秒 读完 (大约 50 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/12/vue3/">vue3</a></h1><div class="content"><a id="more"></a>
<h3 id="compositon-api"><a href="#compositon-api" class="headerlink" title="compositon api"></a>compositon api</h3><ul>
<li><p>与 2.x 版本生命周期相对应的组合式 API<br>beforeCreate -&gt; 使用 setup()<br>created -&gt; 使用 setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>errorCaptured -&gt; onErrorCaptured</p>
</li>
<li><p>新增的钩子函数<br>onRenderTracked<br>onRenderTriggered</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-05-12T10:54:14.000Z" title="2020-05-12T10:54:14.000Z">2020-05-12</time><span class="level-item">3 分钟 读完 (大约 431 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/12/designPatterns/">designPatterns</a></h1><div class="content"><a id="more"></a>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式两个条件</p>
<ul>
<li>确保只有一个实例</li>
<li>可以全局访问</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">singleton.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123; <span class="comment">// 关键点</span></span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> singleton(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  list: &#123;&#125;,</span><br><span class="line">  on(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  emit() &#123;</span><br><span class="line">    <span class="keyword">let</span> key = [].shift.call(<span class="built_in">arguments</span>), fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  remove(key, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">if</span> (!fns) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      fns &amp;&amp; (fns.length = <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fns.forEach(<span class="function">(<span class="params">cb, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn === cb) &#123;</span><br><span class="line">          fns.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅者模式和观察者模式的区别？"><a href="#发布订阅者模式和观察者模式的区别？" class="headerlink" title="发布订阅者模式和观察者模式的区别？"></a>发布订阅者模式和观察者模式的区别？</h3><p>发布/订阅模式是观察者模式的一种变形，两者区别在于，<strong>发布/订阅模式在观察者模式的基础上，在目标和观察者之间增加一个调度中心。</strong><br>单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向。该模式存在不稳定性，发布者无法感知订阅者的状态。</p>
<p>观察者模式是由具体目标调度，比如当事件触发，Subject 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。<br>目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的。</p>
<p>发布/订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-26T06:47:51.000Z" title="2020-04-26T06:47:51.000Z">2020-04-26</time><span class="level-item">30 分钟 读完 (大约 4526 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/26/vue/">vue</a></h1><div class="content"><a id="more"></a>
<h3 id="Vue的优点及缺点"><a href="#Vue的优点及缺点" class="headerlink" title="Vue的优点及缺点"></a>Vue的优点及缺点</h3><p><strong>响应式</strong>：这也就是vue.js最大的优点，通过MVVM思想实现数据的双向绑定，通过虚拟DOM让我们可以用数据来操作DOM，而不必去操作真实的DOM，提升了性能。且让开发者有更多的时间去思考业务逻辑。</p>
<p><strong>组件化</strong>：把一个单页应用中的各个模块拆分到一个个组件当中，或者把一些公共的部分抽离出来做成一个可复用的组件。所以组件化带来的好处就是，提高了开发效率，方便重复使用，使项目的可维护性更强。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>不利于seo。</li>
<li>导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。</li>
<li>初次加载时耗时多。</li>
</ul>
<h3 id="Vue-Router完整的导航解析流程"><a href="#Vue-Router完整的导航解析流程" class="headerlink" title="Vue Router完整的导航解析流程"></a>Vue Router完整的导航解析流程</h3><ul>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ul>
<h3 id="对MVVM的理解"><a href="#对MVVM的理解" class="headerlink" title="对MVVM的理解"></a>对MVVM的理解</h3><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。<br>Model 层: 对应数据层的域模型，它主要做域模型的同步。<br>View 层: 作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。<br>ViewModel 层: 把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。</p>
<h4 id="MVVM优点"><a href="#MVVM优点" class="headerlink" title="MVVM优点"></a>MVVM优点</h4><p>1.分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑<br>2.提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码<br>3.自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放</p>
<h4 id="MVVM缺点"><a href="#MVVM缺点" class="headerlink" title="MVVM缺点"></a>MVVM缺点</h4><p>1.Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的<br>2.一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</p>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex的流向：</p>
<p>view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）<br>view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p>
<p>state 定义了应用状态的数据结构，可以在这里设置默认的初始状态<br>mutations 同步操作，更改store状态,通过commit显示触发<br>actions 用于提交 mutation，而不是直接变更状态，可以包含任意异步操作，通过dispatch分发<br>Module 允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中<br>Getter store的计算属性，返回值会根据它的依赖被缓存起来，处理一些比较复杂的函数</p>
<h3 id="Vue初始化流程"><a href="#Vue初始化流程" class="headerlink" title="Vue初始化流程"></a>Vue初始化流程</h3><ul>
<li>创建Vue实例对象</li>
<li>init过程会初始化生命周期，初始化事件中心，初始化渲染、执行beforeCreate周期函数、初始化 data、props、computed、watcher、执行created周期函数等。</li>
<li>初始化后，调用$mount方法对Vue实例进行挂载（挂载的核心过程包括模板编译、渲染以及更新三个过程）。</li>
<li>如果没有在Vue实例上定义render方法而是定义了template，那么需要经历编译阶段。需要先将template 字符串编译成 render function，template 字符串编译步骤如下 ：<ul>
<li>parse正则解析template字符串形成AST（抽象语法树，是源代码的抽象语法结构的树状表现形式）</li>
<li>optimize标记静态节点跳过diff算法（diff算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有O(n)。如果对于时间复杂度不是很清晰的，可以查看我写的文章ziyi2/algorithms-javascript/渐进记号）</li>
<li>generate将AST转化成render function字符串</li>
</ul>
</li>
<li>编译成render function 后，调用$mount的mountComponent方法，先执行beforeMount钩子函数，然后核心是实例化一个渲染Watcher，在它的回调函数（初始化的时候执行，以及组件实例中监测到数据发生变化时执行）中调用updateComponent方法（此方法调用render方法生成虚拟Node，最终调用update方法更新DOM）。</li>
<li>调用render方法将render function渲染成虚拟的Node（真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。如果频繁的去做 DOM 更新，会产生一定的性能问题，而 Virtual DOM 就是用一个原生的 JavaScript 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多，而且修改属性也很轻松，还可以做到跨平台兼容），render方法的第一个参数是createElement(或者说是h函数)，这个在官方文档也有说明。</li>
<li>生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用pacth方法把虚拟DOM转换成真正的DOM节点。需要注意在图中忽略了新建真实DOM的情况（如果没有旧的虚拟Node，那么可以直接通过createElm创建真实DOM节点），这里重点分析在已有虚拟Node的情况下，会通过sameVnode判断当前需要更新的Node节点是否和旧的Node节点相同（例如我们设置的key属性发生了变化，那么节点显然不同），如果节点不同那么将旧节点采用新节点替换即可，如果相同且存在子节点，需要调用patchVNode方法执行diff算法更新DOM，从而提升DOM操作的性能。</li>
</ul>
<h3 id="Vue双向绑定原理"><a href="#Vue双向绑定原理" class="headerlink" title="Vue双向绑定原理"></a>Vue双向绑定原理</h3><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<ul>
<li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li>
<li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
<li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
<li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。<br><img src="/images/171fec54e0e57df5.webp"></li>
</ul>
<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><ul>
<li>在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。</li>
<li>当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。</li>
</ul>
<h3 id="Vue的数据为什么频繁变化但只会更新一次"><a href="#Vue的数据为什么频繁变化但只会更新一次" class="headerlink" title="Vue的数据为什么频繁变化但只会更新一次"></a>Vue的数据为什么频繁变化但只会更新一次</h3><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MessageChannel</code>，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。<br>另外，关于<code>waiting</code>变量，这是很重要的一个标志位，它保证<code>flushSchedulerQueue</code>回调（$nextTick中执行）允许被置入<code>callbacks</code>一次。<br>因为Vue的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：<br>现在有这样的一种情况，mounted的时候test的值会被循环执行++1000次。 每次++时，都会根据响应式触发<code>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</code>。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个queue队列，在下一个tick（或者是当前tick的微任务阶段）统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick（或者是当前tick的微任务阶段）的时候调用，大大优化了性能。<br>执行顺序<code>update -&gt; queueWatcher -&gt; 维护观察者队列（重复id的Watcher处理） -&gt; waiting标志位处理（保证需要更新DOM或者Watcher视图更新的方法flushSchedulerQueue只会被推入异步执行的$nextTick回调数组一次） -&gt; 处理$nextTick（在为微任务或者宏任务中异步更新DOM）-&gt;</code></p>
<ul>
<li>Vue是异步更新Dom的，Dom的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行</li>
</ul>
<p>由于VUE的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM完成更新，立即执行nextTick(callback)内的回调。</p>
<h3 id="虚拟-Dom-实现原理"><a href="#虚拟-Dom-实现原理" class="headerlink" title="虚拟 Dom 实现原理"></a>虚拟 Dom 实现原理</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<p>(Vue核心之虚拟DOM)[<a href="https://juejin.im/post/5d36cc575188257aea108a74]">https://juejin.im/post/5d36cc575188257aea108a74]</a></p>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p><strong>全局前置守卫</strong><br>注意一定要调用 <code>next()</code>; ，否则钩子就不会被 resolved。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>全局解析守卫</strong><br>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>
<p><strong>全局后置钩子</strong><br>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>路由独享的守卫</strong><br>你可以在路由配置上直接定义 beforeEnter 守卫：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>组件内的守卫</strong><br>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate (2.2 新增)</li>
<li>beforeRouteLeave<br>注意要调用 next()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><p>加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
</li>
<li><p>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li><p>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</p>
</li>
<li><p>销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<h3 id="hash-history-两种模式有什么区别"><a href="#hash-history-两种模式有什么区别" class="headerlink" title="hash / history 两种模式有什么区别"></a>hash / history 两种模式有什么区别</h3><p>Vue底层对它们的实现方式不同</p>
<p>hash模式是依靠onhashchange事件(监听location.hash的改变)</p>
<p>history模式是主要是依靠的HTML5 history中新增的两个方法(监听window.onpopstate)</p>
<ul>
<li>pushState()可以改变url地址且不会发送请求</li>
<li>replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改</li>
</ul>
<p>当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持</p>
<p>因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如<a href="http://www.xxx.com/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面">www.xxx.com/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面</a></p>
<p>(30 道 Vue 面试题)[<a href="https://juejin.im/post/5d59f2a451882549be53b170]">https://juejin.im/post/5d59f2a451882549be53b170]</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-26T06:47:51.000Z" title="2020-04-26T06:47:51.000Z">2020-04-26</time><span class="level-item">4 分钟 读完 (大约 639 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/26/nginx/">vue</a></h1><div class="content"><a id="more"></a>
<h3 id="nginx正向代理、反向代理、负载均衡相关"><a href="#nginx正向代理、反向代理、负载均衡相关" class="headerlink" title="nginx正向代理、反向代理、负载均衡相关"></a>nginx正向代理、反向代理、负载均衡相关</h3><p>1.正向代理<br>正向代理是为客户端服务的，通过代理客户端的请求，去访问客户端本身无法直接访问的服务器，翻墙工具就是最常见的正向代理。正向代理对于客户端透明，对于服务器端不透明。<br>nginx配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  resolver 8.8.8.8;       #指定DNS服务器IP地址 </span><br><span class="line">  listen 80;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;$host;     #设定代理服务器的协议和地址 </span><br><span class="line">    proxy_set_header HOST $host;</span><br><span class="line">    proxy_buffers 256 4k;</span><br><span class="line">    proxy_max_temp_file_size 0k;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.反向代理<br>反向代理是指为服务端服务的，反向代理接收来自客户端的请求，帮助服务器进行请求转发、负载均衡等。通常解决前端跨域问题也是通过反向代理实现的。反向代理对于服务端是透明的，对于客户端是不透明的。<br>nginx配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name  xx.a.com; &#x2F;&#x2F; 监听地址</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    root html;</span><br><span class="line">    proxy_pass xx.b.com; &#x2F;&#x2F; 请求转向地址</span><br><span class="line">    index index.html; &#x2F;&#x2F; 设置默认页</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.负载均衡<br>负载均衡是指nginx将大量客户端的请求合理地分配到各个服务器上，以达到服务端资源的充分利用和更快的响应请求。<br>nginx配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  server_name  xx.a.com;</span><br><span class="line">  listen 80;</span><br><span class="line">  location &#x2F;api &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;balanceServer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>常用的负载均衡策略：</p>
<ul>
<li>轮询策略: 默认策略，遍历服务器节点列表，逐一分配请求，如果服务器down掉，自动剔除。</li>
<li>加权轮询: 每台服务器有不同的权重，一般权重越大意味着该服务器的性能越好，可以承载更多的请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  server 1.1.2.3:80 weight&#x3D;5;</span><br><span class="line">  server 1.1.2.4:80 weight&#x3D;10;</span><br><span class="line">  server 1.1.2.5:80 weight&#x3D;20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最小连接策略: 将请求优先分配给压力较小的服务器，避免压力大的服务器添加更多的请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  least_conn;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最快响应时间策略: 将请求有限分配给响应时间最短的服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  fair;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端ip绑定: 将来自同一个ip的请求永远只分配给一台固定的服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 1.1.2.3:80;</span><br><span class="line">  server 1.1.2.4:80;</span><br><span class="line">  server 1.1.2.5:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://juejin.im/post/5d01bcc7f265da1b91638d75">前端开发者必备的 Nginx 知识</a><br><a href="https://juejin.im/post/5ea931866fb9a043815146fb">nginx万字详解</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-16T08:08:35.000Z" title="2020-04-16T08:08:35.000Z">2020-04-16</time><span class="level-item">几秒 读完 (大约 84 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/16/promise/">promise</a></h1><div class="content"><p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态，而不管其是否处理成功。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-10T02:50:04.000Z" title="2020-04-10T02:50:04.000Z">2020-04-10</time><span class="level-item">4 分钟 读完 (大约 639 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/10/algorithm/">基础算法</a></h1><div class="content"><a id="more"></a>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> isSort = <span class="literal">false</span> <span class="comment">// 优化冒泡排序，表示此次循环没有进行交换，即待排序列已经有序，排序已然完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        isSort = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isSort) <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &gt; arr[j]) &#123; <span class="comment">// 寻找最小值</span></span><br><span class="line">        index = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[index]</span><br><span class="line">      arr[index] = arr[i]</span><br><span class="line">      arr[i] = temp  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> temp,j</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp) &#123;</span><br><span class="line">      arr[j] = arr[j<span class="number">-1</span>]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr === <span class="literal">null</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) <span class="comment">// 获取基准值的index</span></span><br><span class="line">  <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>) <span class="comment">// 获取对应基准值</span></span><br><span class="line">  <span class="keyword">let</span> left = [], right = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...quickSort(left), pivot, ...quickSort(right)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化快速排序（原地排序）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort2</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = left - <span class="number">1</span> <span class="comment">// 定义一个pos指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> pivot = arr[right]</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">        pos++</span><br><span class="line">        <span class="keyword">let</span> swapItem = arr[pos]</span><br><span class="line">        arr[pos] = arr[i]</span><br><span class="line">        arr[i] = swapItem</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一趟排序完成后，pos位置即基准数的位置，以pos的位置左右分割数组</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>)</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还可以再优化<br>1：当是有序数组时，取基准点时也顺序取，就可能导致基准点一侧的子数组一直为空<br>2：数组中重复的数据比较多<code>[1,2,2,2,2,2,2,7]</code>，无论基准点取哪个值，都会导致基准点两侧数组大小不平衡, 影响快排效率</p>
<p>对于第一个问题, 我们可以通过在取基准点的时候随机化来解决，对于第二个问题，我们可以使用三路快排的方式来优化</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">const</span> midIndex = arr.length / <span class="number">2</span> | <span class="number">0</span> <span class="comment">// 向下取整</span></span><br><span class="line">  <span class="keyword">const</span> leftArr = arr.slice(<span class="number">0</span>, midIndex)</span><br><span class="line">  <span class="keyword">const</span> rightArr = arr.slice(midIndex, arr.length)</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(leftArr), mergeSort(rightArr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">leftArr, rightArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (leftArr.length &amp;&amp; rightArr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArr[<span class="number">0</span>] &lt;= rightArr[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(leftArr.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(rightArr.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(leftArr.length) result.push(leftArr.shift())</span><br><span class="line">  <span class="keyword">while</span>(rightArr.length) result.push(rightArr.shift())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> temp = arr[index]</span><br><span class="line">    arr[index] = arr[i]</span><br><span class="line">    arr[i] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LRU算法-Least-Recently-Used-：最近最少使用"><a href="#LRU算法-Least-Recently-Used-：最近最少使用" class="headerlink" title="LRU算法(Least Recently Used ：最近最少使用)"></a>LRU算法(Least Recently Used ：最近最少使用)</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-09T05:32:45.000Z" title="2020-04-09T05:32:45.000Z">2020-04-09</time><span class="level-item">几秒 读完 (大约 0 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/09/utils/">常用工具类函数</a></h1><div class="content"></div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/avatar.png" alt="Panson"></figure><p class="title is-size-4 is-block line-height-inherit">Panson</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-09T09:19:58.000Z">2020-07-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/09/node/">NodeJs</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-08T07:15:16.000Z">2020-07-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/08/note/">note</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-12T05:46:09.000Z">2020-06-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/12/webpack/">webpack</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-12T03:34:36.000Z">2020-06-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/12/vue3/">vue3</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-12T10:54:14.000Z">2020-05-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/12/designPatterns/">designPatterns</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JaveScript/"><span class="tag">JaveScript</span><span class="tag is-grey-lightest">3</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Panson的个人网站" height="28"></a><p class="size-small"><span>&copy; 2020 Panson</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://panpanson.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>